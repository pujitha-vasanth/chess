<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#1e293b">
  <title>Chess Game</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body { overscroll-behavior: none; }
    body { font-family: system-ui, -apple-system, sans-serif; }
  </style>
</head>
<body>
  <div id="root"></div>
  <script>
    // Initialize Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyBl_hoQ27DPlc1A3V6IgulogY5TvwGBW7c",
      authDomain: "chess-d29d2.firebaseapp.com",
      databaseURL: "https://chess-d29d2-default-rtdb.firebaseio.com",
      projectId: "chess-d29d2",
      storageBucket: "chess-d29d2.firebasestorage.app",
      messagingSenderId: "81534677072",
      appId: "1:81534677072:web:fe78bfa92d7d3903fb6155",
      measurementId: "G-WR8FZS72QQ"
    };
    firebase.initializeApp(firebaseConfig);
    window.firebaseDatabase = firebase.database();
  </script>
  <script type="text/babel">


const INITIAL_BOARD = [
  ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
  ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  [null, null, null, null, null, null, null, null],
  ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
  ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
];

const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };

// Standard Chess Piece SVGs - Clean and recognizable
const WhiteKing = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="#fff" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path strokeLinejoin="miter" d="M22.5 11.63V6M20 8h5"/>
      <path strokeLinecap="butt" strokeLinejoin="miter" d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5"/>
      <path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z"/>
      <path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0"/>
    </g>
  </svg>
);

const WhiteQueen = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="#fff" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path d="M8 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zm16.5-4.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM41 12a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM16 8.5a2 2 0 1 1-4 0 2 2 0 1 1 4 0zM33 9a2 2 0 1 1-4 0 2 2 0 1 1 4 0z"/>
      <path strokeLinecap="butt" d="M9 26c8.5-1.5 21-1.5 27 0l2-12-7 11V11l-5.5 13.5-3-15-3 15-5.5-14V25L7 14l2 12z"/>
      <path strokeLinecap="butt" d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z"/>
      <path fill="none" d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0"/>
    </g>
  </svg>
);

const WhiteRook = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="#fff" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path strokeLinecap="butt" d="M9 39h27v-3H9v3zm3-3v-4h21v4H12zm-1-22V9h4v2h5V9h5v2h5V9h4v5"/>
      <path d="M34 14l-3 3H14l-3-3"/>
      <path strokeLinecap="butt" strokeLinejoin="miter" d="M31 17v12.5H14V17"/>
      <path d="M31 29.5l1.5 2.5h-20l1.5-2.5"/>
      <path fill="none" strokeLinejoin="miter" d="M11 14h23"/>
    </g>
  </svg>
);

const WhiteBishop = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="#fff" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <g strokeLinecap="butt">
        <path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/>
        <path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/>
        <path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/>
      </g>
      <path fill="none" strokeLinejoin="miter" d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5"/>
    </g>
  </svg>
);

const WhiteKnight = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="#fff" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21"/>
      <path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3"/>
      <path fill="#000" d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z"/>
    </g>
  </svg>
);

const WhitePawn = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#fff" stroke="#000" strokeWidth="1.5" strokeLinecap="round"/>
  </svg>
);

const BlackKing = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="none" fillRule="evenodd" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path d="M22.5 11.63V6" strokeLinejoin="miter"/>
      <path d="M22.5 25s4.5-7.5 3-10.5c0 0-1-2.5-3-2.5s-3 2.5-3 2.5c-1.5 3 3 10.5 3 10.5" fill="#000" strokeLinecap="butt" strokeLinejoin="miter"/>
      <path d="M11.5 37c5.5 3.5 15.5 3.5 21 0v-7s9-4.5 6-10.5c-4-6.5-13.5-3.5-16 4V27v-3.5c-3.5-7.5-13-10.5-16-4-3 6 5 10 5 10V37z" fill="#000"/>
      <path d="M20 8h5" strokeLinejoin="miter"/>
      <path d="M11.5 30c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0m-21 3.5c5.5-3 15.5-3 21 0" stroke="#fff"/>
    </g>
  </svg>
);

const BlackQueen = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fillRule="evenodd" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <g fill="#000">
        <circle cx="6" cy="12" r="2.75"/>
        <circle cx="14" cy="9" r="2.75"/>
        <circle cx="22.5" cy="8" r="2.75"/>
        <circle cx="31" cy="9" r="2.75"/>
        <circle cx="39" cy="12" r="2.75"/>
      </g>
      <path d="M9 26c8.5-1.5 21-1.5 27 0l2.5-12.5L31 25l-.3-14.1-5.2 13.6-3-14.5-3 14.5-5.2-13.6L14 25 6.5 13.5 9 26z" fill="#000" strokeLinecap="butt"/>
      <path d="M9 26c0 2 1.5 2 2.5 4 1 1.5 1 1 .5 3.5-1.5 1-1.5 2.5-1.5 2.5-1.5 1.5.5 2.5.5 2.5 6.5 1 16.5 1 23 0 0 0 1.5-1 0-2.5 0 0 .5-1.5-1-2.5-.5-2.5-.5-2 .5-3.5 1-2 2.5-2 2.5-4-8.5-1.5-18.5-1.5-27 0z" fill="#000" strokeLinecap="butt"/>
      <path d="M11.5 30c3.5-1 18.5-1 22 0M12 33.5c6-1 15-1 21 0" fill="none" stroke="#fff"/>
    </g>
  </svg>
);

const BlackRook = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fillRule="evenodd" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path d="M9 39h27v-3H9v3zm3.5-7l1.5-2.5h17l1.5 2.5h-20zm-.5 4v-4h21v4H12z" fill="#000" strokeLinecap="butt"/>
      <path d="M14 29.5v-13h17v13H14z" fill="#000" strokeLinecap="butt" strokeLinejoin="miter"/>
      <path d="M14 16.5L11 14h23l-3 2.5H14zM11 14V9h4v2h5V9h5v2h5V9h4v5H11z" fill="#000" strokeLinecap="butt"/>
      <path d="M12 35.5h21m-20-4h19m-18-2.5h17m-17-13h17M11 14h23" fill="none" stroke="#fff" strokeWidth="1" strokeLinejoin="miter"/>
    </g>
  </svg>
);

const BlackBishop = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fillRule="evenodd" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <g fill="#000" strokeLinecap="butt">
        <path d="M9 36c3.39-.97 10.11.43 13.5-2 3.39 2.43 10.11 1.03 13.5 2 0 0 1.65.54 3 2-.68.97-1.65.99-3 .5-3.39-.97-10.11.46-13.5-1-3.39 1.46-10.11.03-13.5 1-1.354.49-2.323.47-3-.5 1.354-1.94 3-2 3-2z"/>
        <path d="M15 32c2.5 2.5 12.5 2.5 15 0 .5-1.5 0-2 0-2 0-2.5-2.5-4-2.5-4 5.5-1.5 6-11.5-5-15.5-11 4-10.5 14-5 15.5 0 0-2.5 1.5-2.5 4 0 0-.5.5 0 2z"/>
        <path d="M25 8a2.5 2.5 0 1 1-5 0 2.5 2.5 0 1 1 5 0z"/>
      </g>
      <path d="M17.5 26h10M15 30h15m-7.5-14.5v5M20 18h5" fill="none" stroke="#fff" strokeLinejoin="miter"/>
    </g>
  </svg>
);

const BlackKnight = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <g fill="none" fillRule="evenodd" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
      <path d="M22 10c10.5 1 16.5 8 16 29H15c0-9 10-6.5 8-21" fill="#000"/>
      <path d="M24 18c.38 2.91-5.55 7.37-8 9-3 2-2.82 4.34-5 4-1.042-.94 1.41-3.04 0-3-1 0 .19 1.23-1 2-1 0-4.003 1-4-4 0-2 6-12 6-12s1.89-1.9 2-3.5c-.73-.994-.5-2-.5-3 1-1 3 2.5 3 2.5h2s.78-1.992 2.5-3c1 0 1 3 1 3" fill="#000"/>
      <path d="M9.5 25.5a.5.5 0 1 1-1 0 .5.5 0 1 1 1 0zm5.433-9.75a.5 1.5 30 1 1-.866-.5.5 1.5 30 1 1 .866.5z" fill="#fff" stroke="#fff"/>
    </g>
  </svg>
);

const BlackPawn = () => (
  <svg viewBox="0 0 45 45" className="w-full h-full">
    <path d="M22.5 9c-2.21 0-4 1.79-4 4 0 .89.29 1.71.78 2.38C17.33 16.5 16 18.59 16 21c0 2.03.94 3.84 2.41 5.03-3 1.06-7.41 5.55-7.41 13.47h23c0-7.92-4.41-12.41-7.41-13.47 1.47-1.19 2.41-3 2.41-5.03 0-2.41-1.33-4.5-3.28-5.62.49-.67.78-1.49.78-2.38 0-2.21-1.79-4-4-4z" fill="#000" stroke="#000" strokeWidth="1.5" strokeLinecap="round"/>
  </svg>
);

const PIECE_COMPONENTS = { 'K': WhiteKing, 'Q': WhiteQueen, 'R': WhiteRook, 'B': WhiteBishop, 'N': WhiteKnight, 'P': WhitePawn, 'k': BlackKing, 'q': BlackQueen, 'r': BlackRook, 'b': BlackBishop, 'n': BlackKnight, 'p': BlackPawn };
const PIECE_SYMBOLS = { 'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô', 'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü' };

const OPENINGS = {
  italian: { name: "Italian Game", description: "Classic attacking setup", playerColor: 'white', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "Let's start with e4. This controls the center and opens lines for your pieces." },
    { from: [1, 4], to: [3, 4], notation: 'e5', voice: "Black plays e5, matching our central control." },
    { from: [7, 6], to: [5, 5], notation: 'Nf3', voice: "Knight to f3. We develop and attack the e5 pawn." },
    { from: [0, 1], to: [2, 2], notation: 'Nc6', voice: "Black defends with the knight." },
    { from: [7, 5], to: [4, 2], notation: 'Bc4', voice: "Bishop to c4. This is the Italian Game! The bishop targets f7." },
    { from: [0, 5], to: [3, 2], notation: 'Bc5', voice: "Black develops their bishop. Both sides are ready." }
  ]},
  sicilian: { name: "Sicilian Defense", description: "Sharp counter-play", playerColor: 'black', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "White opens with e4." },
    { from: [1, 2], to: [3, 2], notation: 'c5', voice: "The Sicilian! We fight for the center asymmetrically." },
    { from: [7, 6], to: [5, 5], notation: 'Nf3', voice: "White develops, preparing d4." },
    { from: [1, 3], to: [3, 3], notation: 'd6', voice: "d6 is solid and flexible." },
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "White pushes d4." },
    { from: [3, 2], to: [4, 3], notation: 'cxd4', voice: "We capture, opening the c-file for later." }
  ]},
  queensGambit: { name: "Queen's Gambit", description: "Strategic pawn sacrifice", playerColor: 'white', moves: [
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "d4 starts the Queen's Gambit." },
    { from: [1, 3], to: [3, 3], notation: 'd5', voice: "Black responds with d5." },
    { from: [6, 2], to: [4, 2], notation: 'c4', voice: "c4, the Queen's Gambit! We offer a pawn to break Black's center." },
    { from: [1, 4], to: [3, 4], notation: 'e6', voice: "Black declines, keeping the structure solid." },
    { from: [7, 1], to: [5, 2], notation: 'Nc3', voice: "Knight to c3, pressuring d5." },
    { from: [0, 6], to: [2, 5], notation: 'Nf6', voice: "Black develops naturally." }
  ]},
  london: { name: "London System", description: "Solid and reliable", playerColor: 'white', moves: [
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "d4 starts the London System." },
    { from: [1, 3], to: [3, 3], notation: 'd5', voice: "Black plays d5." },
    { from: [7, 2], to: [4, 5], notation: 'Bf4', voice: "Bishop to f4 before e3. This is the London!" },
    { from: [0, 6], to: [2, 5], notation: 'Nf6', voice: "Black develops." },
    { from: [6, 4], to: [5, 4], notation: 'e3', voice: "Now e3. Our bishop stays active outside the pawn chain." },
    { from: [1, 4], to: [2, 4], notation: 'e6', voice: "Black's bishop is stuck. Ours is active." }
  ]},
  ruyLopez: { name: "Ruy Lopez", description: "The Spanish Game", playerColor: 'white', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "e4, the king's pawn opening." },
    { from: [1, 4], to: [3, 4], notation: 'e5', voice: "Black responds with e5." },
    { from: [7, 6], to: [5, 5], notation: 'Nf3', voice: "Knight to f3, attacking e5." },
    { from: [0, 1], to: [2, 2], notation: 'Nc6', voice: "Black defends with the knight." },
    { from: [7, 5], to: [3, 1], notation: 'Bb5', voice: "Bishop to b5. This is the Ruy Lopez, one of the oldest openings!" },
    { from: [1, 0], to: [2, 0], notation: 'a6', voice: "Black plays a6, asking the bishop its intentions." }
  ]},
  french: { name: "French Defense", description: "Solid counter-attack", playerColor: 'black', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "White opens with e4." },
    { from: [1, 4], to: [2, 4], notation: 'e6', voice: "e6, the French Defense. We prepare to challenge with d5." },
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "White takes the center." },
    { from: [1, 3], to: [3, 3], notation: 'd5', voice: "Now d5! We strike at White's center." },
    { from: [4, 4], to: [3, 4], notation: 'e5', voice: "White advances, gaining space." },
    { from: [1, 2], to: [2, 2], notation: 'c5', voice: "c5 attacks White's pawn chain from the base." }
  ]},
  caroKann: { name: "Caro-Kann Defense", description: "Solid and sound", playerColor: 'black', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "White plays e4." },
    { from: [1, 2], to: [2, 2], notation: 'c6', voice: "c6, the Caro-Kann. We prepare d5 with pawn support." },
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "White takes the center." },
    { from: [1, 3], to: [3, 3], notation: 'd5', voice: "d5, challenging immediately with full support." },
    { from: [7, 1], to: [5, 2], notation: 'Nc3', voice: "White defends e4." },
    { from: [3, 3], to: [4, 4], notation: 'dxe4', voice: "We capture, leading to clear positions." }
  ]},
  kingsIndian: { name: "King's Indian Defense", description: "Hypermodern counter-attack", playerColor: 'black', moves: [
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "White opens with d4." },
    { from: [0, 6], to: [2, 5], notation: 'Nf6', voice: "Nf6, letting White build the center first." },
    { from: [6, 2], to: [4, 2], notation: 'c4', voice: "White expands." },
    { from: [1, 6], to: [2, 6], notation: 'g6', voice: "g6 prepares to fianchetto the bishop." },
    { from: [7, 1], to: [5, 2], notation: 'Nc3', voice: "White develops." },
    { from: [0, 5], to: [2, 7], notation: 'Bg7', voice: "The bishop takes the long diagonal. Very powerful!" }
  ]},
  scotch: { name: "Scotch Game", description: "Open and tactical", playerColor: 'white', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "e4 to start." },
    { from: [1, 4], to: [3, 4], notation: 'e5', voice: "Black responds e5." },
    { from: [7, 6], to: [5, 5], notation: 'Nf3', voice: "Knight attacks e5." },
    { from: [0, 1], to: [2, 2], notation: 'Nc6', voice: "Black defends." },
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "d4 immediately! This is the Scotch Game, very direct." },
    { from: [3, 4], to: [4, 3], notation: 'exd4', voice: "Black captures." }
  ]},
  vienna: { name: "Vienna Game", description: "Flexible and surprising", playerColor: 'white', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "e4 opens the game." },
    { from: [1, 4], to: [3, 4], notation: 'e5', voice: "Black plays e5." },
    { from: [7, 1], to: [5, 2], notation: 'Nc3', voice: "Nc3, the Vienna Game! Different from Nf3." },
    { from: [0, 6], to: [2, 5], notation: 'Nf6', voice: "Black develops." },
    { from: [7, 5], to: [4, 2], notation: 'Bc4', voice: "Bishop to c4, eyeing f7." },
    { from: [0, 5], to: [3, 2], notation: 'Bc5', voice: "Black matches our development." }
  ]},
  pirc: { name: "Pirc Defense", description: "Modern and flexible", playerColor: 'black', moves: [
    { from: [6, 4], to: [4, 4], notation: 'e4', voice: "White plays e4." },
    { from: [1, 3], to: [2, 3], notation: 'd6', voice: "d6, the Pirc Defense. A modern approach." },
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "White takes the full center." },
    { from: [0, 6], to: [2, 5], notation: 'Nf6', voice: "Nf6 pressures e4." },
    { from: [7, 1], to: [5, 2], notation: 'Nc3', voice: "White defends." },
    { from: [1, 6], to: [2, 6], notation: 'g6', voice: "We fianchetto, preparing to strike back later." }
  ]},
  englund: { name: "Englund Gambit", description: "Aggressive pawn sacrifice", playerColor: 'black', moves: [
    { from: [6, 3], to: [4, 3], notation: 'd4', voice: "White plays d4." },
    { from: [1, 4], to: [3, 4], notation: 'e5', voice: "e5, the Englund Gambit! We sacrifice a pawn for activity." },
    { from: [4, 3], to: [3, 4], notation: 'dxe5', voice: "White accepts." },
    { from: [0, 1], to: [2, 2], notation: 'Nc6', voice: "We develop with tempo on the pawn." },
    { from: [0, 6], to: [2, 5], notation: 'Nf3', voice: "White defends." },
    { from: [0, 3], to: [4, 7], notation: 'Qe7', voice: "Queen eyes the pawn, keeping pressure." }
  ]}
};

function deepCopyBoard(board) { return board.map(row => [...row]); }

function getBoardAtMove(moves, idx) {
  const b = deepCopyBoard(INITIAL_BOARD);
  for (let i = 0; i < idx; i++) { const m = moves[i]; b[m.to[0]][m.to[1]] = b[m.from[0]][m.from[1]]; b[m.from[0]][m.from[1]] = null; }
  return b;
}

function useSpeech() {
  const [isSpeaking, setIsSpeaking] = useState(false);
  const voiceRef = useRef(null);
  useEffect(() => {
    const load = () => { const v = window.speechSynthesis?.getVoices() || []; for (const n of ['Google UK English Female', 'Google US English', 'Samantha']) { const f = v.find(x => x.name.includes(n)); if (f) { voiceRef.current = f; break; } } if (!voiceRef.current) voiceRef.current = v.find(x => x.lang.startsWith('en')) || v[0]; };
    load(); window.speechSynthesis?.addEventListener('voiceschanged', load);
    return () => window.speechSynthesis?.removeEventListener('voiceschanged', load);
  }, []);
  const speak = useCallback((text, onEnd) => { if (!window.speechSynthesis) { onEnd?.(); return; } window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.rate = 0.85; if (voiceRef.current) u.voice = voiceRef.current; u.onstart = () => setIsSpeaking(true); u.onend = () => { setIsSpeaking(false); onEnd?.(); }; u.onerror = () => { setIsSpeaking(false); onEnd?.(); }; setTimeout(() => window.speechSynthesis.speak(u), 150); }, []);
  const stop = useCallback(() => { window.speechSynthesis?.cancel(); setIsSpeaking(false); }, []);
  return { speak, stop, isSpeaking };
}

function useSound() {
  const ctxRef = useRef(null);
  const getCtx = () => { if (!ctxRef.current) ctxRef.current = new (window.AudioContext || window.webkitAudioContext)(); return ctxRef.current; };

  const playMove = useCallback(() => {
    try {
      const ctx = getCtx();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(200, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.05);
      gain.gain.setValueAtTime(0.12, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.1);
    } catch {}
  }, []);

  const playCapture = useCallback(() => {
    try {
      const ctx = getCtx();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'triangle';
      osc.frequency.setValueAtTime(300, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(100, ctx.currentTime + 0.08);
      gain.gain.setValueAtTime(0.15, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.15);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.15);
    } catch {}
  }, []);

  const playGameEnd = useCallback(() => {
    try {
      const ctx = getCtx();
      [261, 329, 392, 523].forEach((f, i) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = f;
        gain.gain.setValueAtTime(0.1, ctx.currentTime + i * 0.15);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i * 0.15 + 0.4);
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.start(ctx.currentTime + i * 0.15);
        osc.stop(ctx.currentTime + i * 0.15 + 0.4);
      });
    } catch {}
  }, []);

  const playError = useCallback(() => {
    try {
      const ctx = getCtx();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = 150;
      gain.gain.setValueAtTime(0.08, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.2);
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.2);
    } catch {}
  }, []);

  return { playMove, playCapture, playGameEnd, playError };
}

function useProgress() {
  const [progress, setProgress] = useState(() => { try { return JSON.parse(localStorage.getItem('chess-progress') || '{}'); } catch { return {}; } });
  const markCompleted = useCallback((k) => { setProgress(p => { const u = { ...p, [k]: { completed: true } }; try { localStorage.setItem('chess-progress', JSON.stringify(u)); } catch {} return u; }); }, []);
  const resetProgress = useCallback(() => { setProgress({}); try { localStorage.removeItem('chess-progress'); } catch {} }, []);
  return { progress, markCompleted, resetProgress };
}

function usePlayerName() {
  const [name, setName] = useState(() => { try { return localStorage.getItem('chess-player-name') || ''; } catch { return ''; } });
  const saveName = useCallback((n) => { setName(n); try { localStorage.setItem('chess-player-name', n); } catch {} }, []);
  const clearName = useCallback(() => { setName(''); try { localStorage.removeItem('chess-player-name'); } catch {} }, []);
  return { name, saveName, clearName };
}

function useTimer(initialMinutes = 10) {
  const [whiteTime, setWhiteTime] = useState(initialMinutes * 60);
  const [blackTime, setBlackTime] = useState(initialMinutes * 60);
  const [isWhiteTurn, setIsWhiteTurn] = useState(true);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);

  useEffect(() => {
    if (isRunning) {
      intervalRef.current = setInterval(() => {
        if (isWhiteTurn) setWhiteTime(t => Math.max(0, t - 1));
        else setBlackTime(t => Math.max(0, t - 1));
      }, 1000);
    }
    return () => clearInterval(intervalRef.current);
  }, [isRunning, isWhiteTurn]);

  const switchTurn = () => setIsWhiteTurn(t => !t);
  const start = () => setIsRunning(true);
  const stop = () => setIsRunning(false);
  const reset = (mins = initialMinutes) => { setWhiteTime(mins * 60); setBlackTime(mins * 60); setIsWhiteTurn(true); setIsRunning(false); };

  return { whiteTime, blackTime, isWhiteTurn, switchTurn, start, stop, reset };
}

function formatTime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}:${s.toString().padStart(2, '0')}`;
}

// Clean modern chess board with green/cream colors - optimized for mobile & desktop
function ChessBoard({ board, selectedSquare, onSquareClick, lastMove, validMoves = [], disabled }) {
  const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
  const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];

  return (
    <div className="flex items-end gap-0.5 sm:gap-1">
      {/* Rank labels */}
      <div className="flex flex-col pb-4 sm:pb-5">
        {ranks.map(r => (
          <div key={r} className="h-[calc((100vw-3rem)/8)] max-h-10 sm:max-h-14 min-h-8 flex items-center justify-center">
            <span className="text-slate-400 text-[10px] sm:text-xs font-medium">{r}</span>
          </div>
        ))}
      </div>
      <div className="flex flex-col">
        {/* Board */}
        <div className="rounded-md overflow-hidden shadow-2xl border-2 border-slate-600 touch-manipulation">
          <div className="grid grid-cols-8">
            {board.map((row, ri) => row.map((piece, ci) => {
              const isLight = (ri + ci) % 2 === 0;
              const isSelected = selectedSquare?.[0] === ri && selectedSquare?.[1] === ci;
              const isLastMoveFrom = lastMove?.from[0] === ri && lastMove?.from[1] === ci;
              const isLastMoveTo = lastMove?.to[0] === ri && lastMove?.to[1] === ci;
              const isValid = validMoves.some(([r, c]) => r === ri && c === ci);
              const Piece = piece ? PIECE_COMPONENTS[piece] : null;
              
              // Color logic
              let bg;
              if (isSelected) {
                bg = 'bg-yellow-400';
              } else if (isLastMoveFrom || isLastMoveTo) {
                bg = isLight ? 'bg-yellow-200' : 'bg-yellow-600';
              } else {
                bg = isLight ? 'bg-emerald-100' : 'bg-emerald-700';
              }
              
              return (
                <div 
                  key={`${ri}-${ci}`} 
                  onClick={() => !disabled && onSquareClick?.(ri, ci)}
                  className={`
                    w-[calc((100vw-3rem)/8)] max-w-10 sm:max-w-14 min-w-8
                    h-[calc((100vw-3rem)/8)] max-h-10 sm:max-h-14 min-h-8
                    flex items-center justify-center ${bg} 
                    ${!disabled ? 'cursor-pointer active:brightness-90 sm:hover:brightness-110' : ''} 
                    relative transition-colors duration-150 select-none
                  `}
                >
                  {isValid && !Piece && <div className="w-2 h-2 sm:w-3 sm:h-3 rounded-full bg-slate-800/40" />}
                  {Piece && (
                    <div className="w-[85%] h-[85%] pointer-events-none">
                      <Piece />
                    </div>
                  )}
                </div>
              );
            }))}
          </div>
        </div>
        {/* File labels */}
        <div className="flex pt-0.5 sm:pt-1">
          {files.map(f => (
            <div key={f} className="w-[calc((100vw-3rem)/8)] max-w-10 sm:max-w-14 min-w-8 flex items-center justify-center">
              <span className="text-slate-400 text-[10px] sm:text-xs font-medium">{f}</span>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

const isWhitePiece = p => p && p === p.toUpperCase();
const isBlackPiece = p => p && p === p.toLowerCase();

function getValidMoves(board, fr, fc) {
  const piece = board[fr][fc]; if (!piece) return [];
  const isW = isWhitePiece(piece), moves = [], pt = piece.toLowerCase();
  const canMoveTo = (r, c) => r >= 0 && r <= 7 && c >= 0 && c <= 7 && (!board[r][c] || (isW ? isBlackPiece(board[r][c]) : isWhitePiece(board[r][c])));
  const empty = (r, c) => r >= 0 && r <= 7 && c >= 0 && c <= 7 && !board[r][c];
  const enemy = (r, c) => r >= 0 && r <= 7 && c >= 0 && c <= 7 && board[r][c] && (isW ? isBlackPiece(board[r][c]) : isWhitePiece(board[r][c]));

  if (pt === 'p') {
    const dir = isW ? -1 : 1, start = isW ? 6 : 1;
    if (empty(fr + dir, fc)) { moves.push([fr + dir, fc]); if (fr === start && empty(fr + 2 * dir, fc)) moves.push([fr + 2 * dir, fc]); }
    if (enemy(fr + dir, fc - 1)) moves.push([fr + dir, fc - 1]);
    if (enemy(fr + dir, fc + 1)) moves.push([fr + dir, fc + 1]);
  }
  if (pt === 'n') { [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]].forEach(([dr, dc]) => { if (canMoveTo(fr + dr, fc + dc)) moves.push([fr + dr, fc + dc]); }); }
  if (pt === 'b' || pt === 'q') { [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([dr, dc]) => { for (let i = 1; i < 8; i++) { const r = fr + dr * i, c = fc + dc * i; if (r < 0 || r > 7 || c < 0 || c > 7) break; if (empty(r, c)) moves.push([r, c]); else if (enemy(r, c)) { moves.push([r, c]); break; } else break; } }); }
  if (pt === 'r' || pt === 'q') { [[-1,0],[1,0],[0,-1],[0,1]].forEach(([dr, dc]) => { for (let i = 1; i < 8; i++) { const r = fr + dr * i, c = fc + dc * i; if (r < 0 || r > 7 || c < 0 || c > 7) break; if (empty(r, c)) moves.push([r, c]); else if (enemy(r, c)) { moves.push([r, c]); break; } else break; } }); }
  if (pt === 'k') { for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) if ((dr || dc) && canMoveTo(fr + dr, fc + dc)) moves.push([fr + dr, fc + dc]); }
  return moves;
}

function getAllMoves(board, isW) {
  const moves = [];
  for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) { const p = board[r][c]; if (p && (isW ? isWhitePiece(p) : isBlackPiece(p))) getValidMoves(board, r, c).forEach(to => moves.push({ from: [r, c], to })); }
  return moves;
}

function evalBoard(board) {
  let score = 0;
  for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
    const p = board[r][c];
    if (p) {
      const v = PIECE_VALUES[p.toLowerCase()] || 0;
      score += isWhitePiece(p) ? v : -v;
      if ((r === 3 || r === 4) && (c === 3 || c === 4)) score += isWhitePiece(p) ? 0.15 : -0.15;
    }
  }
  return score;
}

function makeMove(board, from, to) {
  const b = deepCopyBoard(board);
  const p = b[from[0]][from[1]];
  b[to[0]][to[1]] = p;
  b[from[0]][from[1]] = null;
  if (p === 'P' && to[0] === 0) b[to[0]][to[1]] = 'Q';
  if (p === 'p' && to[0] === 7) b[to[0]][to[1]] = 'q';
  return b;
}

function getComputerMove(board, difficulty = 'intermediate-1') {
  const moves = getAllMoves(board, false);
  if (!moves.length) return null;
  
  // Always capture king if possible
  for (const m of moves) { if (board[m.to[0]][m.to[1]] === 'K') return m; }
  
  // Beginner 1: Almost entirely random
  if (difficulty === 'beginner-1') {
    if (Math.random() < 0.85) return moves[Math.floor(Math.random() * moves.length)];
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const s = evalBoard(nb) + (Math.random() - 0.5) * 5;
      if (s < bestScore) { bestScore = s; best = m; }
    }
    return best;
  }
  
  // Beginner 2: Mostly random, occasionally sees captures
  if (difficulty === 'beginner-2') {
    if (Math.random() < 0.6) return moves[Math.floor(Math.random() * moves.length)];
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const s = evalBoard(nb) + (Math.random() - 0.5) * 3;
      if (s < bestScore) { bestScore = s; best = m; }
    }
    return best;
  }
  
  // Intermediate 1: Considers material with some randomness
  if (difficulty === 'intermediate-1') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const s = evalBoard(nb) + (Math.random() - 0.5) * 2;
      if (s < bestScore) { bestScore = s; best = m; }
    }
    return best;
  }
  
  // Intermediate 2: Looks 1 move ahead with some randomness
  if (difficulty === 'intermediate-2') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      let score = evalBoard(nb);
      
      // Look ahead: what's white's best response?
      const whiteMoves = getAllMoves(nb, true);
      let worstForBlack = -Infinity;
      for (const wm of whiteMoves) {
        const nb2 = makeMove(nb, wm.from, wm.to);
        const s2 = evalBoard(nb2);
        if (s2 > worstForBlack) worstForBlack = s2;
      }
      if (whiteMoves.length > 0) score = worstForBlack;
      score += (Math.random() - 0.5) * 1.5;
      
      if (score < bestScore) { bestScore = score; best = m; }
    }
    return best;
  }
  
  // Intermediate 3: Solid 1-ply with position evaluation
  if (difficulty === 'intermediate-3') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      let score = evalBoardAdvanced(nb);
      
      const whiteMoves = getAllMoves(nb, true);
      let worstForBlack = -Infinity;
      for (const wm of whiteMoves) {
        const nb2 = makeMove(nb, wm.from, wm.to);
        const s2 = evalBoardAdvanced(nb2);
        if (s2 > worstForBlack) worstForBlack = s2;
      }
      if (whiteMoves.length > 0) score = worstForBlack;
      score += (Math.random() - 0.5) * 0.8;
      
      if (score < bestScore) { bestScore = score; best = m; }
    }
    return best;
  }
  
  // Intermediate 4: Strong 1-ply, minimal randomness
  if (difficulty === 'intermediate-4') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      let score = evalBoardAdvanced(nb);
      
      const whiteMoves = getAllMoves(nb, true);
      let worstForBlack = -Infinity;
      for (const wm of whiteMoves) {
        const nb2 = makeMove(nb, wm.from, wm.to);
        const s2 = evalBoardAdvanced(nb2);
        if (s2 > worstForBlack) worstForBlack = s2;
      }
      if (whiteMoves.length > 0) score = worstForBlack;
      score += (Math.random() - 0.5) * 0.3;
      
      if (score < bestScore) { bestScore = score; best = m; }
    }
    return best;
  }
  
  // Advanced 1: 2-ply search (looks 2 moves ahead)
  if (difficulty === 'advanced-1') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      let score = minimaxScore(nb, 2, true);
      score += (Math.random() - 0.5) * 0.4;
      if (score < bestScore) { bestScore = score; best = m; }
    }
    return best;
  }
  
  // Advanced 2: 3-ply search
  if (difficulty === 'advanced-2') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      let score = minimaxScore(nb, 3, true);
      score += (Math.random() - 0.5) * 0.2;
      if (score < bestScore) { bestScore = score; best = m; }
    }
    return best;
  }
  
  // Advanced 3: 4-ply search with alpha-beta pruning, nearly perfect play
  if (difficulty === 'advanced-3') {
    let best = null, bestScore = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      let score = alphabeta(nb, 4, -Infinity, Infinity, true);
      score += (Math.random() - 0.5) * 0.1; // Tiny randomness
      if (score < bestScore) { bestScore = score; best = m; }
    }
    return best;
  }
  
  // Default fallback
  return moves[0];
}

// Advanced board evaluation with positional factors
function evalBoardAdvanced(board) {
  let score = 0;
  
  // Piece-square tables for positional play
  const pawnTable = [
    [0,  0,  0,  0,  0,  0,  0,  0],
    [50, 50, 50, 50, 50, 50, 50, 50],
    [10, 10, 20, 30, 30, 20, 10, 10],
    [5,  5, 10, 25, 25, 10,  5,  5],
    [0,  0,  0, 20, 20,  0,  0,  0],
    [5, -5,-10,  0,  0,-10, -5,  5],
    [5, 10, 10,-20,-20, 10, 10,  5],
    [0,  0,  0,  0,  0,  0,  0,  0]
  ];
  
  const knightTable = [
    [-50,-40,-30,-30,-30,-30,-40,-50],
    [-40,-20,  0,  0,  0,  0,-20,-40],
    [-30,  0, 10, 15, 15, 10,  0,-30],
    [-30,  5, 15, 20, 20, 15,  5,-30],
    [-30,  0, 15, 20, 20, 15,  0,-30],
    [-30,  5, 10, 15, 15, 10,  5,-30],
    [-40,-20,  0,  5,  5,  0,-20,-40],
    [-50,-40,-30,-30,-30,-30,-40,-50]
  ];
  
  const bishopTable = [
    [-20,-10,-10,-10,-10,-10,-10,-20],
    [-10,  0,  0,  0,  0,  0,  0,-10],
    [-10,  0, 10, 10, 10, 10,  0,-10],
    [-10,  5,  5, 10, 10,  5,  5,-10],
    [-10,  0, 10, 10, 10, 10,  0,-10],
    [-10, 10, 10, 10, 10, 10, 10,-10],
    [-10,  5,  0,  0,  0,  0,  5,-10],
    [-20,-10,-10,-10,-10,-10,-10,-20]
  ];
  
  const rookTable = [
    [0,  0,  0,  0,  0,  0,  0,  0],
    [5, 10, 10, 10, 10, 10, 10,  5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [-5,  0,  0,  0,  0,  0,  0, -5],
    [0,  0,  0,  5,  5,  0,  0,  0]
  ];
  
  for (let r = 0; r < 8; r++) {
    for (let c = 0; c < 8; c++) {
      const p = board[r][c];
      if (!p) continue;
      
      const isW = isWhitePiece(p);
      const pt = p.toLowerCase();
      const v = PIECE_VALUES[pt] || 0;
      const row = isW ? r : 7 - r;
      
      let posBonus = 0;
      if (pt === 'p') posBonus = pawnTable[row][c] / 100;
      else if (pt === 'n') posBonus = knightTable[row][c] / 100;
      else if (pt === 'b') posBonus = bishopTable[row][c] / 100;
      else if (pt === 'r') posBonus = rookTable[row][c] / 100;
      else if (pt === 'q') posBonus = ((r === 3 || r === 4) && (c === 3 || c === 4)) ? 0.1 : 0;
      else if (pt === 'k') posBonus = 0;
      
      score += isW ? (v + posBonus) : -(v + posBonus);
    }
  }
  
  return score;
}

// Minimax algorithm for deeper search
function minimaxScore(board, depth, isMaximizing) {
  if (depth === 0) return evalBoardAdvanced(board);
  
  const moves = getAllMoves(board, isMaximizing);
  if (!moves.length) return isMaximizing ? -1000 : 1000;
  
  if (isMaximizing) {
    let maxEval = -Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const ev = minimaxScore(nb, depth - 1, false);
      maxEval = Math.max(maxEval, ev);
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const ev = minimaxScore(nb, depth - 1, true);
      minEval = Math.min(minEval, ev);
    }
    return minEval;
  }
}

// Alpha-beta pruning for efficient deep search
function alphabeta(board, depth, alpha, beta, isMaximizing) {
  if (depth === 0) return evalBoardAdvanced(board);
  
  const moves = getAllMoves(board, isMaximizing);
  if (!moves.length) return isMaximizing ? -1000 : 1000;
  
  // Sort moves for better pruning (captures first)
  moves.sort((a, b) => {
    const capA = board[a.to[0]][a.to[1]] ? 1 : 0;
    const capB = board[b.to[0]][b.to[1]] ? 1 : 0;
    return capB - capA;
  });
  
  if (isMaximizing) {
    let maxEval = -Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const ev = alphabeta(nb, depth - 1, alpha, beta, false);
      maxEval = Math.max(maxEval, ev);
      alpha = Math.max(alpha, ev);
      if (beta <= alpha) break;
    }
    return maxEval;
  } else {
    let minEval = Infinity;
    for (const m of moves) {
      const nb = makeMove(board, m.from, m.to);
      const ev = alphabeta(nb, depth - 1, alpha, beta, true);
      minEval = Math.min(minEval, ev);
      beta = Math.min(beta, ev);
      if (beta <= alpha) break;
    }
    return minEval;
  }
}

function calculateScore(captured) {
  return captured.reduce((sum, p) => sum + (PIECE_VALUES[p.toLowerCase()] || 0), 0);
}

function CapturedPieces({ pieces }) {
  const sorted = [...pieces].sort((a, b) => (PIECE_VALUES[b.toLowerCase()] || 0) - (PIECE_VALUES[a.toLowerCase()] || 0));
  if (!sorted.length) return <span className="text-slate-500 text-sm">None</span>;
  return <div className="flex flex-wrap gap-0.5">{sorted.map((p, i) => <span key={i} className="text-lg">{PIECE_SYMBOLS[p]}</span>)}</div>;
}

function PlayerCard({ name, isWhite, time, isActive, score, capturedPieces, isComputer }) {
  return (
    <div className={`rounded-xl p-2.5 sm:p-3 transition-all ${isActive ? 'bg-green-600/30 ring-2 ring-green-500' : 'bg-slate-800/60'}`}>
      <div className="flex items-center justify-between mb-1.5 sm:mb-2">
        <div className="flex items-center gap-1.5 sm:gap-2 min-w-0">
          <div className={`w-3 h-3 sm:w-4 sm:h-4 rounded-full border-2 flex-shrink-0 ${isWhite ? 'bg-white border-slate-300' : 'bg-slate-900 border-slate-600'}`} />
          <span className="text-white font-medium text-xs sm:text-sm truncate">{name}</span>
          {isComputer && <span className="text-[10px] sm:text-xs bg-slate-700 px-1 sm:px-1.5 py-0.5 rounded text-slate-300 flex-shrink-0">CPU</span>}
        </div>
        <div className={`text-lg sm:text-xl font-mono font-bold flex-shrink-0 ${isActive ? 'text-green-400' : 'text-slate-400'}`}>
          {formatTime(time)}
        </div>
      </div>
      <div className="flex items-center justify-between">
        <div className="flex-1 min-w-0"><CapturedPieces pieces={capturedPieces} /></div>
        <div className="text-green-400 font-bold text-sm sm:text-base flex-shrink-0">+{score}</div>
      </div>
    </div>
  );
}

function PlayMatch({ playerName, onBack, soundEnabled }) {
  const [board, setBoard] = useState(deepCopyBoard(INITIAL_BOARD));
  const [selected, setSelected] = useState(null);
  const [valid, setValid] = useState([]);
  const [lastMove, setLastMove] = useState(null);
  const [status, setStatus] = useState('selecting'); // 'selecting', 'playing', 'kingCaptured', 'timeout'
  const [difficulty, setDifficulty] = useState(null);
  const [winner, setWinner] = useState(null);
  const [history, setHistory] = useState([]);
  const [whiteCaptured, setWhiteCaptured] = useState([]);
  const [blackCaptured, setBlackCaptured] = useState([]);
  const [thinking, setThinking] = useState(false);
  const { playMove, playCapture, playGameEnd } = useSound();
  const timer = useTimer(10);
  const files = ['a','b','c','d','e','f','g','h'];

  const isWhiteTurn = timer.isWhiteTurn;

  useEffect(() => { if (history.length === 1 && !timer.isRunning) timer.start(); }, [history.length]);

  useEffect(() => {
    if (timer.whiteTime === 0 && status === 'playing') { setStatus('timeout'); setWinner('black'); timer.stop(); if (soundEnabled) playGameEnd(); }
    if (timer.blackTime === 0 && status === 'playing') { setStatus('timeout'); setWinner('white'); timer.stop(); if (soundEnabled) playGameEnd(); }
  }, [timer.whiteTime, timer.blackTime, status]);

  const startGame = (diff) => {
    setDifficulty(diff);
    setStatus('playing');
  };

  const notation = (from, to, p, cap) => {
    const pc = p.toLowerCase() === 'p' ? '' : p.toUpperCase();
    return `${p.toLowerCase() === 'p' && cap ? files[from[1]] : ''}${pc}${cap ? 'x' : ''}${files[to[1]]}${8 - to[0]}`;
  };

  const handleClick = (r, c) => {
    if (status !== 'playing' || !isWhiteTurn || thinking) return;
    const p = board[r][c];
    
    if (selected) {
      if (valid.some(([vr, vc]) => vr === r && vc === c)) {
        const mp = board[selected[0]][selected[1]];
        const cap = board[r][c];
        
        if (cap?.toLowerCase() === 'k') {
          const nb = makeMove(board, selected, [r, c]);
          setBoard(nb); setLastMove({ from: selected, to: [r, c] });
          setHistory(h => [...h, notation(selected, [r, c], mp, cap)]);
          if (cap) setWhiteCaptured(prev => [...prev, cap]);
          setStatus('kingCaptured'); setWinner('white'); timer.stop();
          if (soundEnabled) playGameEnd();
          setSelected(null); setValid([]);
          return;
        }
        
        const nb = makeMove(board, selected, [r, c]);
        if (soundEnabled) cap ? playCapture() : playMove();
        if (cap) setWhiteCaptured(prev => [...prev, cap]);
        
        setBoard(nb); setLastMove({ from: selected, to: [r, c] });
        setHistory(h => [...h, notation(selected, [r, c], mp, cap)]);
        timer.switchTurn(); setSelected(null); setValid([]);
        
        // CPU move with delay - no hints, just thinking then move
        setThinking(true);
        
        // Thinking time varies by difficulty - advanced takes longer
        const thinkTimes = {
          'beginner-1': 800,
          'beginner-2': 1000,
          'intermediate-1': 1200,
          'intermediate-2': 1500,
          'intermediate-3': 1800,
          'intermediate-4': 2000,
          'advanced-1': 2500,
          'advanced-2': 3500,
          'advanced-3': 4500,
        };
        const thinkTime = thinkTimes[difficulty] || 1500;
        
        setTimeout(() => {
          const cm = getComputerMove(nb, difficulty);
          if (cm) {
            const cp = nb[cm.from[0]][cm.from[1]];
            const cc = nb[cm.to[0]][cm.to[1]];
            
            if (cc?.toLowerCase() === 'k') {
              const ab = makeMove(nb, cm.from, cm.to);
              setBoard(ab); 
              setLastMove(cm);
              setHistory(h => [...h, notation(cm.from, cm.to, cp, cc)]);
              if (cc) setBlackCaptured(prev => [...prev, cc]);
              setStatus('kingCaptured'); setWinner('black'); timer.stop();
              if (soundEnabled) playGameEnd();
              setThinking(false);
              return;
            }
            
            const ab = makeMove(nb, cm.from, cm.to);
            if (soundEnabled) cc ? playCapture() : playMove();
            if (cc) setBlackCaptured(prev => [...prev, cc]);
            
            setBoard(ab); 
            setLastMove(cm); // Highlights both FROM and TO squares after move
            setHistory(h => [...h, notation(cm.from, cm.to, cp, cc)]);
            timer.switchTurn();
            setThinking(false);
          } else {
            setThinking(false);
          }
        }, thinkTime);
        
      } else if (p && isWhitePiece(p)) {
        setSelected([r, c]); setValid(getValidMoves(board, r, c));
      } else {
        setSelected(null); setValid([]);
      }
    } else if (p && isWhitePiece(p)) {
      setSelected([r, c]); setValid(getValidMoves(board, r, c));
    }
  };

  const reset = () => {
    setBoard(deepCopyBoard(INITIAL_BOARD)); setSelected(null); setValid([]); setLastMove(null);
    setStatus('selecting'); setDifficulty(null); setWinner(null); setHistory([]);
    setWhiteCaptured([]); setBlackCaptured([]); setThinking(false);
    timer.reset();
  };

  const whiteScore = calculateScore(whiteCaptured);
  const blackScore = calculateScore(blackCaptured);
  const materialDiff = whiteScore - blackScore;

  const DIFFICULTY_LEVELS = [
    { id: 'beginner-1', name: 'Beginner 1', desc: 'Almost random moves', color: 'green', icon: 'üå±' },
    { id: 'beginner-2', name: 'Beginner 2', desc: 'Occasionally sees captures', color: 'green', icon: 'üåø' },
    { id: 'intermediate-1', name: 'Intermediate 1', desc: 'Considers material value', color: 'yellow', icon: '‚öîÔ∏è' },
    { id: 'intermediate-2', name: 'Intermediate 2', desc: 'Looks 1 move ahead', color: 'yellow', icon: 'üó°Ô∏è' },
    { id: 'intermediate-3', name: 'Intermediate 3', desc: 'Positional awareness', color: 'yellow', icon: 'üõ°Ô∏è' },
    { id: 'intermediate-4', name: 'Intermediate 4', desc: 'Strong tactical play', color: 'orange', icon: '‚ö°' },
    { id: 'advanced-1', name: 'Advanced 1', desc: 'Looks 2 moves ahead', color: 'red', icon: 'üî•' },
    { id: 'advanced-2', name: 'Advanced 2', desc: 'Looks 3 moves ahead', color: 'red', icon: 'üíÄ' },
    { id: 'advanced-3', name: 'Advanced 3', desc: 'Near-perfect play', color: 'purple', icon: 'üëë' },
  ];

  const getColorClasses = (color) => {
    const colors = {
      green: 'bg-green-600/20 hover:bg-green-600/30 border-green-600/50',
      yellow: 'bg-yellow-600/20 hover:bg-yellow-600/30 border-yellow-600/50',
      orange: 'bg-orange-600/20 hover:bg-orange-600/30 border-orange-600/50',
      red: 'bg-red-600/20 hover:bg-red-600/30 border-red-600/50',
      purple: 'bg-purple-600/20 hover:bg-purple-600/30 border-purple-600/50',
    };
    return colors[color];
  };

  const getBadgeColor = (color) => {
    const colors = {
      green: 'bg-green-600',
      yellow: 'bg-yellow-600',
      orange: 'bg-orange-600',
      red: 'bg-red-600',
      purple: 'bg-purple-600',
    };
    return colors[color];
  };

  // Difficulty selection screen
  if (status === 'selecting') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
        <div className="max-w-lg mx-auto">
          <button onClick={onBack} className="text-slate-400 hover:text-white text-sm mb-6">‚Üê Back to menu</button>
          
          <div className="text-center mb-6">
            <h1 className="text-2xl font-bold text-white mb-2">Choose Difficulty</h1>
            <p className="text-slate-400 text-sm">9 levels from casual to crushing</p>
          </div>
          
          <div className="space-y-2">
            {DIFFICULTY_LEVELS.map((level, idx) => (
              <button 
                key={level.id} 
                onClick={() => startGame(level.id)} 
                className={`w-full p-3 rounded-xl text-left border transition-all ${getColorClasses(level.color)}`}
              >
                <div className="flex items-center gap-3">
                  <div className={`w-9 h-9 rounded-lg ${getBadgeColor(level.color)} flex items-center justify-center text-lg`}>{level.icon}</div>
                  <div className="flex-1">
                    <div className="flex items-center gap-2">
                      <h2 className="font-semibold text-white text-sm">{level.name}</h2>
                      <div className="flex gap-0.5">
                        {Array.from({ length: idx + 1 }).map((_, i) => (
                          <div key={i} className={`w-1.5 h-1.5 rounded-full ${getBadgeColor(level.color)}`} />
                        ))}
                      </div>
                    </div>
                    <p className="text-slate-400 text-xs">{level.desc}</p>
                  </div>
                </div>
              </button>
            ))}
          </div>
          
          <p className="text-slate-500 text-xs text-center mt-4">üí° Advanced levels may take longer to think</p>
        </div>
      </div>
    );
  }

  const getDifficultyDisplay = () => {
    const level = DIFFICULTY_LEVELS.find(l => l.id === difficulty);
    return level ? { name: level.name, color: getBadgeColor(level.color) } : { name: difficulty, color: 'bg-slate-600' };
  };

  const diffDisplay = getDifficultyDisplay();

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-2 sm:p-4 lg:p-6">
      <div className="max-w-5xl mx-auto">
        {/* Header */}
        <div className="mb-2 sm:mb-4">
          <button onClick={onBack} className="text-slate-400 hover:text-white text-xs sm:text-sm mb-1 sm:mb-2">‚Üê Back</button>
          <div className="flex items-center gap-2 sm:gap-3">
            <h1 className="text-lg sm:text-2xl font-bold text-white">vs Computer</h1>
            <span className={`text-[10px] sm:text-xs px-1.5 sm:px-2 py-0.5 sm:py-1 rounded ${diffDisplay.color} text-white`}>{diffDisplay.name}</span>
          </div>
        </div>

        {/* Mobile: Opponent info bar above board */}
        <div className="lg:hidden mb-2">
          <div className={`rounded-lg p-2 flex items-center justify-between ${!isWhiteTurn && status === 'playing' ? 'bg-green-600/30 ring-1 ring-green-500' : 'bg-slate-800/60'}`}>
            <div className="flex items-center gap-2">
              <div className="w-3 h-3 rounded-full bg-slate-900 border border-slate-600" />
              <span className="text-white text-sm font-medium">Computer</span>
              <span className="text-[10px] bg-slate-700 px-1 py-0.5 rounded text-slate-300">CPU</span>
            </div>
            <div className={`font-mono font-bold ${!isWhiteTurn ? 'text-green-400' : 'text-slate-400'}`}>{formatTime(timer.blackTime)}</div>
          </div>
        </div>

        <div className="flex flex-col lg:flex-row gap-3 sm:gap-6 items-center lg:items-start">
          {/* Chess Board */}
          <div className="flex-shrink-0">
            <ChessBoard board={board} selectedSquare={selected} onSquareClick={handleClick} lastMove={lastMove} validMoves={valid} disabled={status !== 'playing' || !isWhiteTurn || thinking} />
          </div>

          {/* Mobile: Player info bar below board */}
          <div className="lg:hidden w-full">
            <div className={`rounded-lg p-2 flex items-center justify-between ${isWhiteTurn && status === 'playing' ? 'bg-green-600/30 ring-1 ring-green-500' : 'bg-slate-800/60'}`}>
              <div className="flex items-center gap-2">
                <div className="w-3 h-3 rounded-full bg-white border border-slate-300" />
                <span className="text-white text-sm font-medium">{playerName}</span>
              </div>
              <div className={`font-mono font-bold ${isWhiteTurn ? 'text-green-400' : 'text-slate-400'}`}>{formatTime(timer.whiteTime)}</div>
            </div>
          </div>

          {/* Status messages - show on mobile */}
          {(status === 'kingCaptured' || status === 'timeout') && (
            <div className={`lg:hidden w-full rounded-xl p-3 text-center ${winner === 'white' ? 'bg-green-600/30 border border-green-500' : 'bg-red-600/30 border border-red-500'}`}>
              <p className="text-base font-bold text-white">
                {status === 'kingCaptured' && (winner === 'white' ? 'üëë You Win!' : 'üíÄ You Lost!')}
                {status === 'timeout' && (winner === 'white' ? '‚è∞ You Win!' : '‚è∞ Time Out!')}
              </p>
            </div>
          )}

          {thinking && (
            <div className="lg:hidden w-full bg-blue-600/20 border border-blue-500/50 rounded-lg p-2 text-center">
              <p className="text-blue-300 animate-pulse text-sm">ü§î Thinking...</p>
            </div>
          )}

          {/* New Game button - always visible on mobile */}
          <button onClick={reset} className="lg:hidden w-full py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-medium text-sm">
            üîÑ New Game
          </button>

          {/* Desktop sidebar */}
          <div className="hidden lg:block flex-1 w-full max-w-xs space-y-3">
            <PlayerCard name="Computer" isWhite={false} time={timer.blackTime} isActive={!isWhiteTurn && status === 'playing'} score={blackScore} capturedPieces={blackCaptured} isComputer />

            {(status === 'kingCaptured' || status === 'timeout') && (
              <div className={`rounded-xl p-4 text-center ${winner === 'white' ? 'bg-green-600/30 border border-green-500' : 'bg-red-600/30 border border-red-500'}`}>
                <p className="text-lg font-bold text-white mb-1">
                  {status === 'kingCaptured' && (winner === 'white' ? 'üëë King Captured!' : 'üíÄ Your King Captured!')}
                  {status === 'timeout' && (winner === 'white' ? '‚è∞ Time Out!' : '‚è∞ You Ran Out of Time!')}
                </p>
                <p className="text-slate-300">{winner === 'white' ? 'You Win!' : 'Computer Wins!'}</p>
              </div>
            )}

            {thinking && (
              <div className="bg-blue-600/20 border border-blue-500/50 rounded-xl p-3 text-center">
                <p className="text-blue-300 animate-pulse">ü§î Computer is thinking...</p>
              </div>
            )}

            <PlayerCard name={playerName} isWhite={true} time={timer.whiteTime} isActive={isWhiteTurn && status === 'playing'} score={whiteScore} capturedPieces={whiteCaptured} isComputer={false} />

            <div className="bg-slate-800/60 rounded-xl p-3 text-center">
              <span className="text-slate-400 text-sm">Material: </span>
              <span className={`font-bold ${materialDiff > 0 ? 'text-green-400' : materialDiff < 0 ? 'text-red-400' : 'text-slate-300'}`}>
                {materialDiff > 0 ? `+${materialDiff}` : materialDiff < 0 ? materialDiff : 'Even'}
              </span>
            </div>

            <div className="bg-slate-800/60 rounded-xl p-3 max-h-32 overflow-y-auto">
              <p className="text-slate-500 text-xs uppercase mb-2">Moves</p>
              <div className="space-y-1 font-mono text-xs">
                {!history.length && <p className="text-slate-600">No moves yet</p>}
                {Array.from({ length: Math.ceil(history.length / 2) }).map((_, i) => (
                  <div key={i} className="flex gap-2">
                    <span className="text-slate-500 w-4">{i + 1}.</span>
                    <span className="text-white w-12">{history[i * 2]}</span>
                    <span className="text-slate-400">{history[i * 2 + 1] || ''}</span>
                  </div>
                ))}
              </div>
            </div>

            <button onClick={reset} className="w-full py-2.5 bg-slate-700 hover:bg-slate-600 text-white rounded-xl font-medium transition-colors">
              üîÑ New Game
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

function PlayMultiplayer({ player1Name, onBack, soundEnabled }) {
  const [board, setBoard] = useState(deepCopyBoard(INITIAL_BOARD));
  const [selected, setSelected] = useState(null);
  const [valid, setValid] = useState([]);
  const [lastMove, setLastMove] = useState(null);
  const [status, setStatus] = useState('setup'); // 'setup', 'playing', 'kingCaptured', 'timeout'
  const [player2Name, setPlayer2Name] = useState('');
  const [winner, setWinner] = useState(null);
  const [history, setHistory] = useState([]);
  const [whiteCaptured, setWhiteCaptured] = useState([]);
  const [blackCaptured, setBlackCaptured] = useState([]);
  const { playMove, playCapture, playGameEnd } = useSound();
  const timer = useTimer(10);
  const files = ['a','b','c','d','e','f','g','h'];

  const isWhiteTurn = timer.isWhiteTurn;

  useEffect(() => { if (history.length === 1 && !timer.isRunning) timer.start(); }, [history.length]);

  useEffect(() => {
    if (timer.whiteTime === 0 && status === 'playing') { setStatus('timeout'); setWinner('black'); timer.stop(); if (soundEnabled) playGameEnd(); }
    if (timer.blackTime === 0 && status === 'playing') { setStatus('timeout'); setWinner('white'); timer.stop(); if (soundEnabled) playGameEnd(); }
  }, [timer.whiteTime, timer.blackTime, status]);

  const startGame = () => {
    if (player2Name.trim()) {
      setStatus('playing');
    }
  };

  const notation = (from, to, p, cap) => {
    const pc = p.toLowerCase() === 'p' ? '' : p.toUpperCase();
    return `${p.toLowerCase() === 'p' && cap ? files[from[1]] : ''}${pc}${cap ? 'x' : ''}${files[to[1]]}${8 - to[0]}`;
  };

  const handleClick = (r, c) => {
    if (status !== 'playing') return;
    const p = board[r][c];
    const isCurrentPlayerPiece = isWhiteTurn ? isWhitePiece(p) : isBlackPiece(p);
    
    if (selected) {
      if (valid.some(([vr, vc]) => vr === r && vc === c)) {
        const mp = board[selected[0]][selected[1]];
        const cap = board[r][c];
        
        if (cap?.toLowerCase() === 'k') {
          const nb = makeMove(board, selected, [r, c]);
          setBoard(nb); setLastMove({ from: selected, to: [r, c] });
          setHistory(h => [...h, notation(selected, [r, c], mp, cap)]);
          if (cap) {
            if (isWhiteTurn) setWhiteCaptured(prev => [...prev, cap]);
            else setBlackCaptured(prev => [...prev, cap]);
          }
          setStatus('kingCaptured'); setWinner(isWhiteTurn ? 'white' : 'black'); timer.stop();
          if (soundEnabled) playGameEnd();
          setSelected(null); setValid([]);
          return;
        }
        
        const nb = makeMove(board, selected, [r, c]);
        if (soundEnabled) cap ? playCapture() : playMove();
        if (cap) {
          if (isWhiteTurn) setWhiteCaptured(prev => [...prev, cap]);
          else setBlackCaptured(prev => [...prev, cap]);
        }
        
        setBoard(nb); setLastMove({ from: selected, to: [r, c] });
        setHistory(h => [...h, notation(selected, [r, c], mp, cap)]);
        timer.switchTurn(); setSelected(null); setValid([]);
        
      } else if (isCurrentPlayerPiece) {
        setSelected([r, c]); setValid(getValidMoves(board, r, c));
      } else {
        setSelected(null); setValid([]);
      }
    } else if (isCurrentPlayerPiece) {
      setSelected([r, c]); setValid(getValidMoves(board, r, c));
    }
  };

  const reset = () => {
    setBoard(deepCopyBoard(INITIAL_BOARD)); setSelected(null); setValid([]); setLastMove(null);
    setStatus('setup'); setWinner(null); setHistory([]);
    setWhiteCaptured([]); setBlackCaptured([]); setPlayer2Name('');
    timer.reset();
  };

  const whiteScore = calculateScore(whiteCaptured);
  const blackScore = calculateScore(blackCaptured);
  const materialDiff = whiteScore - blackScore;

  // Player 2 name entry
  if (status === 'setup') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
        <div className="max-w-md mx-auto">
          <button onClick={onBack} className="text-slate-400 hover:text-white text-sm mb-6">‚Üê Back to menu</button>
          
          <div className="text-center mb-8">
            <div className="text-4xl mb-3">üë•</div>
            <h1 className="text-2xl font-bold text-white mb-2">Local Multiplayer</h1>
            <p className="text-slate-400">Play with a friend on the same device</p>
          </div>
          
          <div className="bg-slate-800/60 rounded-xl p-5 border border-slate-700 mb-4">
            <div className="flex items-center gap-3 mb-4 pb-4 border-b border-slate-700">
              <div className="w-4 h-4 rounded-full bg-white border-2 border-slate-300" />
              <div>
                <p className="text-white font-medium">{player1Name}</p>
                <p className="text-slate-500 text-xs">White pieces</p>
              </div>
            </div>
            <div className="flex items-center gap-3">
              <div className="w-4 h-4 rounded-full bg-slate-900 border-2 border-slate-600" />
              <div className="flex-1">
                <input 
                  type="text" 
                  value={player2Name} 
                  onChange={e => setPlayer2Name(e.target.value)}
                  placeholder="Player 2 name"
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white placeholder-slate-400 focus:outline-none focus:border-purple-500 text-sm"
                  onKeyDown={e => e.key === 'Enter' && player2Name.trim() && startGame()}
                  autoFocus
                />
                <p className="text-slate-500 text-xs mt-1">Black pieces</p>
              </div>
            </div>
          </div>
          
          <button 
            onClick={startGame}
            disabled={!player2Name.trim()}
            className="w-full py-3 bg-purple-600 hover:bg-purple-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-xl font-medium text-white"
          >
            Start Game ‚öîÔ∏è
          </button>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
      <div className="max-w-5xl mx-auto">
        <div className="mb-4">
          <button onClick={onBack} className="text-slate-400 hover:text-white text-sm mb-2">‚Üê Back to menu</button>
          <div className="flex items-center gap-3">
            <h1 className="text-2xl font-bold text-white">Local Multiplayer</h1>
            <span className="text-xs px-2 py-1 rounded bg-purple-600 text-white">2 Players</span>
          </div>
        </div>

        <div className="flex flex-col lg:flex-row gap-6 items-start">
          <ChessBoard board={board} selectedSquare={selected} onSquareClick={handleClick} lastMove={lastMove} validMoves={valid} disabled={status !== 'playing'} />

          <div className="flex-1 w-full max-w-xs space-y-3">
            <PlayerCard name={player2Name} isWhite={false} time={timer.blackTime} isActive={!isWhiteTurn && status === 'playing'} score={blackScore} capturedPieces={blackCaptured} isComputer={false} />

            {(status === 'kingCaptured' || status === 'timeout') && (
              <div className={`rounded-xl p-4 text-center ${winner === 'white' ? 'bg-green-600/30 border border-green-500' : 'bg-purple-600/30 border border-purple-500'}`}>
                <p className="text-lg font-bold text-white mb-1">
                  {status === 'kingCaptured' && 'üëë King Captured!'}
                  {status === 'timeout' && '‚è∞ Time Out!'}
                </p>
                <p className="text-slate-300">{winner === 'white' ? `${player1Name} Wins!` : `${player2Name} Wins!`}</p>
              </div>
            )}

            {status === 'playing' && (
              <div className={`rounded-xl p-3 text-center ${isWhiteTurn ? 'bg-white/10 border border-white/30' : 'bg-slate-800/60 border border-slate-600'}`}>
                <p className={`font-medium ${isWhiteTurn ? 'text-white' : 'text-slate-400'}`}>
                  {isWhiteTurn ? `${player1Name}'s turn` : `${player2Name}'s turn`}
                </p>
              </div>
            )}

            <PlayerCard name={player1Name} isWhite={true} time={timer.whiteTime} isActive={isWhiteTurn && status === 'playing'} score={whiteScore} capturedPieces={whiteCaptured} isComputer={false} />

            <div className="bg-slate-800/60 rounded-xl p-3 text-center">
              <span className="text-slate-400 text-sm">Material: </span>
              <span className={`font-bold ${materialDiff > 0 ? 'text-green-400' : materialDiff < 0 ? 'text-red-400' : 'text-slate-300'}`}>
                {materialDiff > 0 ? `+${materialDiff}` : materialDiff < 0 ? materialDiff : 'Even'}
              </span>
            </div>

            <div className="bg-slate-800/60 rounded-xl p-3 max-h-32 overflow-y-auto">
              <p className="text-slate-500 text-xs uppercase mb-2">Moves</p>
              <div className="space-y-1 font-mono text-xs">
                {!history.length && <p className="text-slate-600">No moves yet</p>}
                {Array.from({ length: Math.ceil(history.length / 2) }).map((_, i) => (
                  <div key={i} className="flex gap-2">
                    <span className="text-slate-500 w-4">{i + 1}.</span>
                    <span className="text-white w-12">{history[i * 2]}</span>
                    <span className="text-slate-400">{history[i * 2 + 1] || ''}</span>
                  </div>
                ))}
              </div>
            </div>

            <button onClick={reset} className="w-full py-2.5 bg-slate-700 hover:bg-slate-600 text-white rounded-xl font-medium transition-colors">
              üîÑ New Game
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}

// Generate random game code
function generateGameCode() {
  const words = ['KNIGHT', 'BISHOP', 'CASTLE', 'QUEEN', 'KING', 'PAWN', 'ROOK', 'CHECK'];
  const word = words[Math.floor(Math.random() * words.length)];
  const num = Math.floor(1000 + Math.random() * 9000);
  return `${word}-${num}`;
}

// Online Multiplayer with Firebase
function PlayOnline({ playerName, onBack, soundEnabled }) {
  const [gameCode, setGameCode] = useState('');
  const [inputCode, setInputCode] = useState('');
  const [status, setStatus] = useState('menu');
  const [playerColor, setPlayerColor] = useState(null);
  const [opponentName, setOpponentName] = useState('');
  const [board, setBoard] = useState(deepCopyBoard(INITIAL_BOARD));
  const [selected, setSelected] = useState(null);
  const [valid, setValid] = useState([]);
  const [lastMove, setLastMove] = useState(null);
  const [isWhiteTurn, setIsWhiteTurn] = useState(true);
  const [winner, setWinner] = useState(null);
  const [history, setHistory] = useState([]);
  const [whiteCaptured, setWhiteCaptured] = useState([]);
  const [blackCaptured, setBlackCaptured] = useState([]);
  const [connectionStatus, setConnectionStatus] = useState('disconnected');
  const [copied, setCopied] = useState(false);
  const [error, setError] = useState('');
  const { playMove, playCapture, playGameEnd } = useSound();
  const files = ['a','b','c','d','e','f','g','h'];
  const unsubscribeRef = useRef(null);
  const database = window.firebaseDatabase;

  // Create a new game in Firebase
  const createGame = async () => {
    if (!database) {
      setError('Firebase not connected. Check your internet.');
      return;
    }
    
    const code = generateGameCode();
    setGameCode(code);
    setPlayerColor('white');
    setStatus('waiting');
    setConnectionStatus('connecting');
    setError('');
    
    try {
      await database.ref(`games/${code}`).set({
        status: 'waiting',
        host: playerName,
        hostColor: 'white',
        guest: null,
        board: INITIAL_BOARD,
        isWhiteTurn: true,
        lastMove: null,
        history: [],
        whiteCaptured: [],
        blackCaptured: [],
        winner: null,
        createdAt: Date.now()
      });
      setConnectionStatus('waiting');
      subscribeToGame(code);
    } catch (err) {
      setError('Failed to create game. Check your connection.');
      setStatus('menu');
    }
  };

  // Join existing game
  const joinGame = async () => {
    if (!database) {
      setError('Firebase not connected. Check your internet.');
      return;
    }
    
    const code = inputCode.toUpperCase().trim();
    if (!code) return;
    
    setStatus('joining');
    setError('');
    
    try {
      const snapshot = await database.ref(`games/${code}`).once('value');
      const game = snapshot.val();
      
      if (!game) {
        setError('Game not found! Check the code.');
        setStatus('menu');
        return;
      }
      
      if (game.guest) {
        setError('Game already has two players!');
        setStatus('menu');
        return;
      }
      
      await database.ref(`games/${code}`).update({
        guest: playerName,
        status: 'playing'
      });
      
      setGameCode(code);
      setPlayerColor('black');
      setOpponentName(game.host);
      setBoard(game.board);
      setStatus('playing');
      setConnectionStatus('connected');
      subscribeToGame(code);
    } catch (err) {
      setError('Failed to join game. Check your connection.');
      setStatus('menu');
    }
  };

  // Subscribe to game updates
  const subscribeToGame = (code) => {
    if (!database) return;
    if (unsubscribeRef.current) unsubscribeRef.current();
    
    const gameRef = database.ref(`games/${code}`);
    const callback = gameRef.on('value', (snapshot) => {
      const game = snapshot.val();
      if (!game) return;
      
      if (game.guest && status === 'waiting') {
        setOpponentName(game.guest);
        setStatus('playing');
        setConnectionStatus('connected');
      }
      
      setBoard(game.board || INITIAL_BOARD);
      setIsWhiteTurn(game.isWhiteTurn !== false);
      setLastMove(game.lastMove || null);
      setHistory(game.history || []);
      setWhiteCaptured(game.whiteCaptured || []);
      setBlackCaptured(game.blackCaptured || []);
      
      if (game.winner && !winner) {
        setWinner(game.winner);
        setStatus('ended');
        if (soundEnabled) playGameEnd();
      }
    });
    
    unsubscribeRef.current = () => gameRef.off('value', callback);
  };

  useEffect(() => {
    return () => { if (unsubscribeRef.current) unsubscribeRef.current(); };
  }, []);

  const notation = (from, to, p, cap) => {
    const pc = p.toLowerCase() === 'p' ? '' : p.toUpperCase();
    return `${p.toLowerCase() === 'p' && cap ? files[from[1]] : ''}${pc}${cap ? 'x' : ''}${files[to[1]]}${8 - to[0]}`;
  };

  const isMyTurn = (isWhiteTurn && playerColor === 'white') || (!isWhiteTurn && playerColor === 'black');

  const handleClick = async (r, c) => {
    if (status !== 'playing' || !isMyTurn || !database) return;
    
    const p = board[r][c];
    const isMyPiece = playerColor === 'white' ? isWhitePiece(p) : isBlackPiece(p);
    
    if (selected) {
      if (valid.some(([vr, vc]) => vr === r && vc === c)) {
        const mp = board[selected[0]][selected[1]];
        const cap = board[r][c];
        const nb = makeMove(board, selected, [r, c]);
        const newHistory = [...history, notation(selected, [r, c], mp, cap)];
        const newWhiteCaptured = cap && playerColor === 'white' ? [...whiteCaptured, cap] : whiteCaptured;
        const newBlackCaptured = cap && playerColor === 'black' ? [...blackCaptured, cap] : blackCaptured;
        
        if (soundEnabled) cap ? playCapture() : playMove();
        
        const isKingCapture = cap?.toLowerCase() === 'k';
        
        try {
          await database.ref(`games/${gameCode}`).update({
            board: nb,
            isWhiteTurn: !isWhiteTurn,
            lastMove: { from: selected, to: [r, c] },
            history: newHistory,
            whiteCaptured: newWhiteCaptured,
            blackCaptured: newBlackCaptured,
            winner: isKingCapture ? playerColor : null
          });
        } catch (err) {
          setError('Failed to sync move.');
        }
        
        setSelected(null);
        setValid([]);
      } else if (isMyPiece) {
        setSelected([r, c]);
        setValid(getValidMoves(board, r, c));
      } else {
        setSelected(null);
        setValid([]);
      }
    } else if (isMyPiece) {
      setSelected([r, c]);
      setValid(getValidMoves(board, r, c));
    }
  };

  const copyCode = () => {
    navigator.clipboard?.writeText(gameCode);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const leaveGame = () => {
    if (unsubscribeRef.current) unsubscribeRef.current();
    setStatus('menu');
    setGameCode('');
    setInputCode('');
    setPlayerColor(null);
    setOpponentName('');
    setBoard(deepCopyBoard(INITIAL_BOARD));
    setSelected(null);
    setValid([]);
    setLastMove(null);
    setIsWhiteTurn(true);
    setWinner(null);
    setHistory([]);
    setWhiteCaptured([]);
    setBlackCaptured([]);
    setConnectionStatus('disconnected');
    setError('');
  };

  // Menu screen
  if (status === 'menu') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
        <div className="max-w-md mx-auto">
          <button onClick={onBack} className="text-slate-400 hover:text-white text-sm mb-6">‚Üê Back to menu</button>
          
          <div className="text-center mb-8">
            <div className="text-4xl mb-3">üåê</div>
            <h1 className="text-2xl font-bold text-white mb-2">Online Multiplayer</h1>
            <p className="text-slate-400 text-sm">Play with anyone, anywhere!</p>
            {database && (
              <div className="flex items-center justify-center gap-2 mt-2">
                <div className="w-2 h-2 bg-green-500 rounded-full animate-pulse" />
                <span className="text-green-400 text-xs">Connected</span>
              </div>
            )}
          </div>
          
          {error && (
            <div className="bg-red-600/20 border border-red-500 rounded-lg p-3 mb-4 text-red-300 text-sm text-center">
              {error}
            </div>
          )}
          
          <div className="space-y-4">
            <button onClick={createGame} className="w-full p-4 rounded-xl text-left bg-green-600/20 hover:bg-green-600/30 active:bg-green-600/40 border border-green-600/50 transition-all">
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 rounded-lg bg-green-600 flex items-center justify-center text-xl">‚ûï</div>
                <div>
                  <h2 className="font-semibold text-white">Create Game</h2>
                  <p className="text-slate-400 text-sm">Get a code to share</p>
                </div>
              </div>
            </button>
            
            <div className="text-center text-slate-500 text-sm">‚Äî or ‚Äî</div>
            
            <div className="bg-slate-800/60 rounded-xl p-4 border border-slate-700">
              <h3 className="font-medium text-white mb-3">Join with Code</h3>
              <div className="flex gap-2">
                <input
                  type="text"
                  value={inputCode}
                  onChange={e => setInputCode(e.target.value.toUpperCase())}
                  placeholder="KNIGHT-1234"
                  className="flex-1 bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-white placeholder-slate-400 focus:outline-none focus:border-cyan-500 font-mono text-center uppercase"
                  onKeyDown={e => e.key === 'Enter' && joinGame()}
                />
                <button onClick={joinGame} className="px-4 py-2 bg-cyan-600 hover:bg-cyan-500 rounded-lg text-white font-medium">
                  Join
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  // Waiting for opponent
  if (status === 'waiting') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
        <div className="max-w-md mx-auto text-center">
          <button onClick={leaveGame} className="text-slate-400 hover:text-white text-sm mb-6 block mx-auto">‚Üê Cancel</button>
          
          <div className="text-5xl mb-4 animate-pulse">‚è≥</div>
          <h1 className="text-2xl font-bold text-white mb-2">Waiting for opponent...</h1>
          <p className="text-slate-400 mb-6">Share this code with your friend</p>
          
          <div className="bg-slate-800 rounded-xl p-6 border border-slate-700 mb-6">
            <p className="text-slate-400 text-xs uppercase mb-2">Game Code</p>
            <div className="flex items-center justify-center gap-3">
              <span className="text-3xl font-mono font-bold text-green-400 tracking-wider">{gameCode}</span>
              <button onClick={copyCode} className="p-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white">
                {copied ? '‚úì' : 'üìã'}
              </button>
            </div>
          </div>
          
          <div className="space-y-3">
            <p className="text-slate-500 text-sm">Share via:</p>
            <div className="flex justify-center gap-3 flex-wrap">
              <a href={`mailto:?subject=Let's play chess!&body=Join my chess game with code: ${gameCode}`} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white text-sm">
                üìß Email
              </a>
              <a href={`https://wa.me/?text=Let's play chess! Join with code: ${gameCode}`} target="_blank" rel="noopener noreferrer" className="px-4 py-2 bg-green-700 hover:bg-green-600 rounded-lg text-white text-sm">
                üí¨ WhatsApp
              </a>
              <button onClick={copyCode} className="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white text-sm">
                üìã Copy
              </button>
            </div>
          </div>
          
          <div className="mt-6 flex items-center justify-center gap-2 text-yellow-500 text-sm">
            <div className="w-2 h-2 bg-yellow-500 rounded-full animate-pulse" />
            Waiting for player 2...
          </div>
        </div>
      </div>
    );
  }

  // Game in progress or ended
  const myName = playerName;
  const theirName = opponentName || 'Opponent';
  const amIWhite = playerColor === 'white';
  const whiteScore = calculateScore(whiteCaptured);
  const blackScore = calculateScore(blackCaptured);

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-2 sm:p-4 lg:p-6">
      <div className="max-w-5xl mx-auto">
        <div className="mb-2 sm:mb-4">
          <button onClick={leaveGame} className="text-slate-400 hover:text-white text-xs sm:text-sm mb-1">‚Üê Leave</button>
          <div className="flex items-center gap-2 sm:gap-3 flex-wrap">
            <h1 className="text-lg sm:text-2xl font-bold text-white">Online Game</h1>
            <span className="text-[10px] sm:text-xs px-1.5 sm:px-2 py-0.5 sm:py-1 rounded bg-cyan-600 text-white font-mono">{gameCode}</span>
            <div className="flex items-center gap-1">
              <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse" />
              <span className="text-[10px] text-green-400">Live</span>
            </div>
          </div>
        </div>

        {error && (
          <div className="bg-red-600/20 border border-red-500 rounded-lg p-2 mb-2 text-red-300 text-xs text-center">{error}</div>
        )}

        <div className="lg:hidden mb-2">
          <div className={`rounded-lg p-2 flex items-center justify-between ${!isMyTurn && status === 'playing' ? 'bg-green-600/30 ring-1 ring-green-500' : 'bg-slate-800/60'}`}>
            <div className="flex items-center gap-2">
              <div className={`w-3 h-3 rounded-full ${amIWhite ? 'bg-slate-900 border border-slate-600' : 'bg-white border border-slate-300'}`} />
              <span className="text-white text-sm font-medium">{theirName}</span>
            </div>
            {!isMyTurn && status === 'playing' && <span className="text-green-400 text-xs animate-pulse">Their turn</span>}
          </div>
        </div>

        <div className="flex flex-col lg:flex-row gap-3 sm:gap-6 items-center lg:items-start">
          <div className="flex-shrink-0">
            <ChessBoard 
              board={amIWhite ? board : [...board].reverse().map(row => [...row].reverse())} 
              selectedSquare={selected ? (amIWhite ? selected : [7 - selected[0], 7 - selected[1]]) : null}
              onSquareClick={(r, c) => handleClick(amIWhite ? r : 7 - r, amIWhite ? c : 7 - c)}
              lastMove={lastMove ? {
                from: amIWhite ? lastMove.from : [7 - lastMove.from[0], 7 - lastMove.from[1]],
                to: amIWhite ? lastMove.to : [7 - lastMove.to[0], 7 - lastMove.to[1]]
              } : null}
              validMoves={amIWhite ? valid : valid.map(([r, c]) => [7 - r, 7 - c])}
              disabled={status !== 'playing' || !isMyTurn}
            />
          </div>

          <div className="lg:hidden w-full">
            <div className={`rounded-lg p-2 flex items-center justify-between ${isMyTurn && status === 'playing' ? 'bg-green-600/30 ring-1 ring-green-500' : 'bg-slate-800/60'}`}>
              <div className="flex items-center gap-2">
                <div className={`w-3 h-3 rounded-full ${amIWhite ? 'bg-white border border-slate-300' : 'bg-slate-900 border border-slate-600'}`} />
                <span className="text-white text-sm font-medium">{myName} (You)</span>
              </div>
              {isMyTurn && status === 'playing' && <span className="text-green-400 text-xs animate-pulse">Your turn!</span>}
            </div>
          </div>

          {status === 'ended' && (
            <div className={`lg:hidden w-full rounded-xl p-3 text-center ${winner === playerColor ? 'bg-green-600/30 border border-green-500' : 'bg-red-600/30 border border-red-500'}`}>
              <p className="text-base font-bold text-white">{winner === playerColor ? 'üëë You Win!' : 'üíÄ You Lost!'}</p>
            </div>
          )}

          <button onClick={leaveGame} className="lg:hidden w-full py-2 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-medium text-sm">üö™ Leave Game</button>

          <div className="hidden lg:block flex-1 w-full max-w-xs space-y-3">
            <div className={`rounded-xl p-3 ${!isMyTurn && status === 'playing' ? 'bg-green-600/30 ring-2 ring-green-500' : 'bg-slate-800/60'}`}>
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                  <div className={`w-4 h-4 rounded-full ${amIWhite ? 'bg-slate-900 border-2 border-slate-600' : 'bg-white border-2 border-slate-300'}`} />
                  <span className="text-white font-medium text-sm">{theirName}</span>
                </div>
              </div>
              <CapturedPieces pieces={amIWhite ? blackCaptured : whiteCaptured} />
            </div>

            {status === 'playing' && (
              <div className={`rounded-xl p-3 text-center ${isMyTurn ? 'bg-green-600/30 border border-green-500' : 'bg-slate-800/60 border border-slate-600'}`}>
                <p className={`font-medium ${isMyTurn ? 'text-green-400' : 'text-slate-400'}`}>
                  {isMyTurn ? '‚ú® Your turn!' : `‚è≥ Waiting for ${theirName}...`}
                </p>
              </div>
            )}

            {status === 'ended' && (
              <div className={`rounded-xl p-4 text-center ${winner === playerColor ? 'bg-green-600/30 border border-green-500' : 'bg-red-600/30 border border-red-500'}`}>
                <p className="text-lg font-bold text-white">{winner === playerColor ? 'üëë Victory!' : 'üíÄ Defeat!'}</p>
              </div>
            )}

            <div className={`rounded-xl p-3 ${isMyTurn && status === 'playing' ? 'bg-green-600/30 ring-2 ring-green-500' : 'bg-slate-800/60'}`}>
              <div className="flex items-center justify-between mb-2">
                <div className="flex items-center gap-2">
                  <div className={`w-4 h-4 rounded-full ${amIWhite ? 'bg-white border-2 border-slate-300' : 'bg-slate-900 border-2 border-slate-600'}`} />
                  <span className="text-white font-medium text-sm">{myName}</span>
                  <span className="text-xs bg-green-600 px-1.5 py-0.5 rounded text-white">You</span>
                </div>
              </div>
              <CapturedPieces pieces={amIWhite ? whiteCaptured : blackCaptured} />
            </div>

            <div className="bg-slate-800/60 rounded-xl p-3 max-h-32 overflow-y-auto">
              <p className="text-slate-500 text-xs uppercase mb-2">Moves</p>
              <div className="space-y-1 font-mono text-xs">
                {!history.length && <p className="text-slate-600">No moves yet</p>}
                {Array.from({ length: Math.ceil(history.length / 2) }).map((_, i) => (
                  <div key={i} className="flex gap-2">
                    <span className="text-slate-500 w-4">{i + 1}.</span>
                    <span className="text-white w-12">{history[i * 2]}</span>
                    <span className="text-slate-400">{history[i * 2 + 1] || ''}</span>
                  </div>
                ))}
              </div>
            </div>

            <button onClick={leaveGame} className="w-full py-2.5 bg-slate-700 hover:bg-slate-600 text-white rounded-xl font-medium">üö™ Leave Game</button>
          </div>
        </div>
      </div>
    </div>
  );
}

// Opening trainer components
function DemoMode({ opening, onComplete, onSkip, soundEnabled, voiceEnabled }) {
  const [idx, setIdx] = useState(0);
  const [playing, setPlaying] = useState(false);
  const [waiting, setWaiting] = useState(false);
  const { speak, stop, isSpeaking } = useSpeech();
  const { playMove } = useSound();
  const timerRef = useRef(null);
  const board = getBoardAtMove(opening.moves, idx);
  const last = idx > 0 ? opening.moves[idx - 1] : null;
  const voice = idx > 0 ? opening.moves[idx - 1].voice : null;

  useEffect(() => {
    if (timerRef.current) clearTimeout(timerRef.current);
    if (!playing || waiting || idx >= opening.moves.length) return;
    timerRef.current = setTimeout(() => {
      if (soundEnabled) playMove();
      setIdx(i => i + 1);
      if (voiceEnabled && opening.moves[idx]?.voice) { setWaiting(true); speak(opening.moves[idx].voice, () => setWaiting(false)); }
    }, idx === 0 ? 600 : 800);
    return () => clearTimeout(timerRef.current);
  }, [playing, waiting, idx, opening.moves, soundEnabled, voiceEnabled, playMove, speak]);

  useEffect(() => { if (idx >= opening.moves.length) setPlaying(false); }, [idx, opening.moves.length]);

  const toggle = () => { if (idx >= opening.moves.length) { stop(); setWaiting(false); setIdx(0); setTimeout(() => setPlaying(true), 100); } else { if (playing) { stop(); setWaiting(false); } setPlaying(!playing); } };
  const seek = i => { stop(); setWaiting(false); setIdx(Math.max(0, Math.min(opening.moves.length, i))); setPlaying(false); };
  const next = () => { stop(); setWaiting(false); setPlaying(false); if (idx < opening.moves.length) { if (soundEnabled) playMove(); setIdx(idx + 1); if (voiceEnabled && opening.moves[idx]?.voice) speak(opening.moves[idx].voice); } };
  const prev = () => { stop(); setWaiting(false); setIdx(i => Math.max(0, i - 1)); setPlaying(false); };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
      <div className="max-w-5xl mx-auto">
        <div className="mb-4">
          <button onClick={() => { stop(); onSkip(); }} className="text-slate-400 hover:text-white text-sm mb-2">‚Üê Back</button>
          <div className="flex items-center gap-3"><h1 className="text-2xl font-bold text-white">{opening.name}</h1><span className="text-xs px-2 py-1 bg-blue-600 rounded text-white">Demo</span></div>
        </div>
        <div className="flex flex-col lg:flex-row gap-6 items-start">
          <ChessBoard board={board} lastMove={last} disabled />
          <div className="flex-1 max-w-xs w-full space-y-3">
            <div className="bg-slate-800/60 rounded-xl p-4">
              <div className="flex items-center gap-2 mb-2">
                <div className="w-8 h-8 rounded-full bg-blue-600 flex items-center justify-center text-sm">üéì</div>
                <div><p className="text-white text-sm font-medium">Coach</p>{isSpeaking && <p className="text-blue-400 text-xs">Speaking...</p>}</div>
              </div>
              <p className="text-slate-300 text-sm leading-relaxed min-h-[40px]">{voice || "Press play to begin."}</p>
              {idx > 0 && <p className="text-blue-400 text-xs mt-2 font-mono">Move {idx}: {opening.moves[idx - 1]?.notation}</p>}
            </div>
            <div className="bg-slate-800/60 rounded-xl p-3">
              <div className="mb-3"><div className="h-2 bg-slate-700 rounded-full cursor-pointer" onClick={e => { const r = e.currentTarget.getBoundingClientRect(); seek(Math.round(((e.clientX - r.left) / r.width) * opening.moves.length)); }}><div className="h-full bg-blue-500 rounded-full transition-all" style={{ width: `${(idx / opening.moves.length) * 100}%` }} /></div><div className="flex justify-between text-xs text-slate-500 mt-1"><span>{idx}/{opening.moves.length}</span></div></div>
              <div className="flex items-center justify-center gap-2">
                <button onClick={prev} disabled={idx === 0} className="p-2 text-slate-400 hover:text-white disabled:text-slate-600"><svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg></button>
                <button onClick={toggle} className="p-3 bg-blue-600 hover:bg-blue-500 rounded-full">{playing ? <svg className="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg> : <svg className="w-5 h-5 text-white" fill="currentColor" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>}</button>
                <button onClick={next} disabled={idx >= opening.moves.length} className="p-2 text-slate-400 hover:text-white disabled:text-slate-600"><svg className="w-5 h-5" fill="currentColor" viewBox="0 0 24 24"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg></button>
              </div>
            </div>
            {idx >= opening.moves.length && <button onClick={() => { stop(); onComplete(); }} className="w-full py-2.5 bg-green-600 hover:bg-green-500 rounded-xl font-medium text-white">Practice Now ‚Üí</button>}
          </div>
        </div>
      </div>
    </div>
  );
}

function PracticeMode({ opening, onBack, onRewatch, soundEnabled, onComplete }) {
  const [board, setBoard] = useState(deepCopyBoard(INITIAL_BOARD));
  const [selected, setSelected] = useState(null);
  const [idx, setIdx] = useState(0);
  const [msg, setMsg] = useState('');
  const [msgType, setMsgType] = useState('info');
  const [last, setLast] = useState(null);
  const [hint, setHint] = useState(false);
  const [stats, setStats] = useState({ ok: 0, err: 0 });
  const [done, setDone] = useState(false);
  const { playMove, playGameEnd, playError } = useSound();

  useEffect(() => { if (opening.playerColor === 'black') setTimeout(() => compMove(0), 500); else setMsg("Your move"); }, []);

  const compMove = i => {
    if (i >= opening.moves.length) return;
    const m = opening.moves[i];
    if (soundEnabled) playMove();
    setBoard(b => { const n = deepCopyBoard(b); n[m.to[0]][m.to[1]] = n[m.from[0]][m.from[1]]; n[m.from[0]][m.from[1]] = null; return n; });
    setLast(m); setIdx(i + 1);
    if (i + 1 >= opening.moves.length) { setDone(true); setMsg("Perfect! üéâ"); setMsgType('success'); if (soundEnabled) playGameEnd(); onComplete?.(); }
    else { setMsg("Your move"); setMsgType('info'); }
  };

  const handleClick = (r, c) => {
    if (done || idx >= opening.moves.length) return;
    const exp = opening.moves[idx], isTurn = (idx % 2 === 0) === (opening.playerColor === 'white');
    if (!isTurn) return;
    if (selected) {
      const [fr, fc] = selected, p = board[fr][fc];
      if (fr === exp.from[0] && fc === exp.from[1] && r === exp.to[0] && c === exp.to[1]) {
        if (soundEnabled) playMove();
        const nb = deepCopyBoard(board); nb[r][c] = p; nb[fr][fc] = null;
        setBoard(nb); setLast(exp); setIdx(idx + 1); setStats(s => ({ ...s, ok: s.ok + 1 })); setHint(false);
        if (idx + 1 >= opening.moves.length) { setDone(true); setMsg("Perfect! üéâ"); setMsgType('success'); if (soundEnabled) playGameEnd(); onComplete?.(); }
        else { setMsg("Correct!"); setMsgType('success'); setTimeout(() => compMove(idx + 1), 500); }
      } else if (r === fr && c === fc) setSelected(null);
      else if (board[r][c] && (opening.playerColor === 'white' ? isWhitePiece(board[r][c]) : isBlackPiece(board[r][c]))) setSelected([r, c]);
      else { if (soundEnabled) playError(); setMsg("Try again"); setMsgType('error'); setStats(s => ({ ...s, err: s.err + 1 })); setSelected(null); }
    } else if (board[r][c] && (opening.playerColor === 'white' ? isWhitePiece(board[r][c]) : isBlackPiece(board[r][c]))) setSelected([r, c]);
  };

  const files = ['a','b','c','d','e','f','g','h'], sq = (r, c) => `${files[c]}${8 - r}`;
  const restart = () => { setBoard(deepCopyBoard(INITIAL_BOARD)); setSelected(null); setIdx(0); setMsg(''); setLast(null); setHint(false); setDone(false); setStats({ ok: 0, err: 0 }); if (opening.playerColor === 'black') setTimeout(() => compMove(0), 500); else setMsg("Your move"); };

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
      <div className="max-w-5xl mx-auto">
        <div className="mb-4">
          <button onClick={onBack} className="text-slate-400 hover:text-white text-sm mb-2">‚Üê Back</button>
          <div className="flex items-center gap-3"><h1 className="text-2xl font-bold text-white">{opening.name}</h1><span className="text-xs px-2 py-1 bg-slate-600 rounded text-white">Practice</span></div>
          <p className="text-slate-400 text-sm mt-1">Playing as {opening.playerColor}</p>
        </div>
        <div className="flex flex-col lg:flex-row gap-6 items-start">
          <ChessBoard board={board} selectedSquare={selected} onSquareClick={handleClick} lastMove={last} disabled={false} />
          <div className="flex-1 max-w-xs w-full space-y-3">
            <div className={`rounded-xl p-4 text-center ${msgType === 'success' ? 'bg-green-600/30 border border-green-500' : msgType === 'error' ? 'bg-red-600/30 border border-red-500' : 'bg-slate-800/60'}`}>
              <p className={`text-lg font-medium ${msgType === 'success' ? 'text-green-300' : msgType === 'error' ? 'text-red-300' : 'text-slate-200'}`}>{msg || 'Select a piece'}</p>
            </div>
            <div className="bg-slate-800/60 rounded-xl p-3">
              <div className="h-2 bg-slate-700 rounded-full mb-2"><div className="h-full bg-green-500 rounded-full transition-all" style={{ width: `${(idx / opening.moves.length) * 100}%` }} /></div>
              <div className="flex justify-between text-sm"><span className="text-green-400">{stats.ok} correct</span><span className="text-red-400">{stats.err} wrong</span></div>
            </div>
            {!done && <button onClick={() => setHint(!hint)} className={`w-full py-2.5 rounded-xl border ${hint ? 'bg-blue-600/30 border-blue-500 text-blue-300' : 'bg-slate-800/60 border-slate-600 text-slate-300'}`}>{hint ? 'üí° Hide hint' : 'üí° Show hint'}</button>}
            {hint && !done && idx < opening.moves.length && <div className="bg-blue-600/20 border border-blue-500/50 rounded-xl p-3 text-center"><p className="text-blue-300 font-mono">{opening.moves[idx].notation}</p><p className="text-blue-400/70 text-xs">{sq(...opening.moves[idx].from)} ‚Üí {sq(...opening.moves[idx].to)}</p></div>}
            <div className="space-y-2">
              <button onClick={onRewatch} className="w-full py-2.5 bg-slate-700 hover:bg-slate-600 text-white rounded-xl">üì∫ Rewatch</button>
              <button onClick={restart} className="w-full py-2.5 bg-slate-700 hover:bg-slate-600 text-white rounded-xl">üîÑ Restart</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

function OpeningSelect({ onSelect, onBack, progress, onResetProgress }) {
  const done = Object.keys(progress).filter(k => progress[k]?.completed).length, total = Object.keys(OPENINGS).length;
  const [showReset, setShowReset] = useState(false);
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
      <div className="max-w-4xl mx-auto">
        <button onClick={onBack} className="text-slate-400 hover:text-white text-sm mb-4">‚Üê Back</button>
        <div className="text-center mb-6">
          <h1 className="text-3xl font-bold text-white mb-2">Chess Openings</h1>
          <p className="text-slate-400 mb-4">Master the essential first moves</p>
          <div className="max-w-xs mx-auto bg-slate-800/60 rounded-xl p-3">
            <div className="flex justify-between text-xs text-slate-400 mb-1"><span>Progress</span><span>{done}/{total}</span></div>
            <div className="h-2 bg-slate-700 rounded-full"><div className="h-full bg-green-500 rounded-full" style={{ width: `${(done / total) * 100}%` }} /></div>
          </div>
          {done > 0 && (
            <button onClick={() => setShowReset(true)} className="text-slate-500 hover:text-slate-300 text-xs mt-2">Reset progress</button>
          )}
        </div>
        
        {showReset && (
          <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
            <div className="bg-slate-800 rounded-xl p-6 max-w-sm border border-slate-700">
              <h3 className="text-lg font-bold text-white mb-2">Reset Progress?</h3>
              <p className="text-slate-400 text-sm mb-4">This will clear all your completed openings.</p>
              <div className="flex gap-2">
                <button onClick={() => setShowReset(false)} className="flex-1 py-2 bg-slate-700 rounded-lg text-white">Cancel</button>
                <button onClick={() => { onResetProgress(); setShowReset(false); }} className="flex-1 py-2 bg-red-600 rounded-lg text-white">Reset</button>
              </div>
            </div>
          </div>
        )}
        
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
          {Object.entries(OPENINGS).map(([k, o]) => (
            <button key={k} onClick={() => onSelect(k)} className="group text-left p-4 rounded-xl bg-slate-800/60 hover:bg-slate-700/60 border border-slate-700 hover:border-slate-500 transition-all relative">
              {progress[k]?.completed && <span className="absolute top-3 right-3 w-5 h-5 bg-green-600 rounded-full flex items-center justify-center text-xs text-white">‚úì</span>}
              <h3 className="text-base font-semibold text-white group-hover:text-green-400 mb-1">{o.name}</h3>
              <p className="text-slate-400 text-xs mb-2">{o.description}</p>
              <div className="flex gap-1.5">
                <span className={`text-xs px-2 py-0.5 rounded ${o.playerColor === 'white' ? 'bg-white text-slate-900' : 'bg-slate-900 text-white border border-slate-600'}`}>{o.playerColor}</span>
                <span className="text-xs px-2 py-0.5 rounded bg-slate-700 text-slate-300">{o.moves.length} moves</span>
              </div>
            </button>
          ))}
        </div>
      </div>
    </div>
  );
}

// Witty greetings for returning players
const GREETINGS = [
  "Back for more? Your pieces missed you! üéØ",
  "The board awaits, champion! ‚ôüÔ∏è",
  "Ready to sacrifice some pawns for glory? üòà",
  "Let's turn some pawns into queens today! üëë",
  "Your opponent's king is getting nervous... üò∞",
  "Time to checkmate and chill! üßä",
  "The chess gods smile upon your return! ‚ö°",
  "Another day, another chance for brilliance! ‚ú®",
  "Your pieces have been practicing while you were gone! üí™",
  "Legend says you're unbeatable today... üèÜ",
  "Ready to make Magnus Carlsen jealous? üòé",
  "The 64 squares of destiny await! üé≤",
  "Plot twist: You're the main character today! üåü",
  "Time to turn caffeine into checkmates! ‚òï",
  "Your knight is ready to jump into action! üê¥"
];

// Famous chess quotes
const CHESS_QUOTES = [
  { quote: "Chess is life in miniature.", author: "Garry Kasparov" },
  { quote: "Every chess master was once a beginner.", author: "Irving Chernev" },
  { quote: "The beauty of chess is it can be whatever you want it to be.", author: "Simon Williams" },
  { quote: "Chess is the gymnasium of the mind.", author: "Blaise Pascal" },
  { quote: "In chess, as in life, forethought wins.", author: "Charles Buxton" },
  { quote: "Chess holds its master in its own bonds.", author: "Albert Einstein" },
  { quote: "Chess is everything: art, science, and sport.", author: "Anatoly Karpov" },
  { quote: "When you see a good move, look for a better one.", author: "Emanuel Lasker" },
  { quote: "Chess is a war over the board.", author: "Bobby Fischer" },
  { quote: "The pawns are the soul of chess.", author: "Fran√ßois-Andr√© Philidor" },
  { quote: "Chess makes men wiser and clear-sighted.", author: "Vladimir Putin" },
  { quote: "I don't believe in psychology. I believe in good moves.", author: "Bobby Fischer" },
  { quote: "Chess is mental torture.", author: "Garry Kasparov" },
  { quote: "Tactics is knowing what to do when there is something to do.", author: "Savielly Tartakower" },
  { quote: "Chess is a forcing house where the weights of character are tested.", author: "Reuben Fine" }
];

// Pro tips for chess improvement
const PRO_TIPS = [
  "üí° Control the center with your pawns and pieces early in the game.",
  "üí° Develop your knights and bishops before moving the same piece twice.",
  "üí° Castle early to protect your king and connect your rooks.",
  "üí° Don't bring your queen out too early - she can become a target.",
  "üí° Every move should have a purpose: develop, attack, or defend.",
  "üí° Knights are stronger in closed positions, bishops in open ones.",
  "üí° Rooks belong on open files and the 7th rank.",
  "üí° A knight on the rim is grim - keep knights centralized.",
  "üí° When ahead in material, trade pieces. When behind, trade pawns.",
  "üí° The threat is stronger than the execution - keep your opponent guessing.",
  "üí° Always ask: What is my opponent's threat?",
  "üí° Doubled pawns are usually a weakness - avoid them when possible.",
  "üí° Passed pawns must be pushed! They can become queens.",
  "üí° In the endgame, activate your king - he's a fighting piece!",
  "üí° Time is a piece too - don't waste it on unnecessary moves."
];

function getRandomItem(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function NameEntry({ initialName, onSubmit }) {
  const [name, setName] = useState(initialName);
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 flex items-center justify-center p-6">
      <div className="max-w-sm w-full text-center">
        <div className="text-5xl mb-4">‚ôüÔ∏è</div>
        <h1 className="text-2xl font-bold text-white mb-2">Welcome to Chess</h1>
        <p className="text-slate-400 mb-6 text-sm">Enter your name to begin</p>
        <div className="bg-slate-800/60 rounded-xl p-5 border border-slate-700">
          <input type="text" value={name} onChange={e => setName(e.target.value)} placeholder="Your name" className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2.5 text-white placeholder-slate-400 focus:outline-none focus:border-green-500 text-center" autoFocus onKeyDown={e => e.key === 'Enter' && name.trim() && onSubmit(name.trim())} />
          <button onClick={() => name.trim() && onSubmit(name.trim())} disabled={!name.trim()} className="w-full mt-3 py-2.5 bg-green-600 hover:bg-green-500 disabled:bg-slate-700 disabled:text-slate-500 rounded-lg font-medium text-white">Continue</button>
        </div>
      </div>
    </div>
  );
}

function SettingsButton({ onClick }) {
  return (
    <button onClick={onClick} className="fixed top-4 right-4 p-2.5 bg-slate-800/80 hover:bg-slate-700 border border-slate-600 rounded-xl text-slate-400 hover:text-white transition-all z-40">
      <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
    </button>
  );
}

function SettingsModal({ show, onClose, soundEnabled, setSoundEnabled, voiceEnabled, setVoiceEnabled, onChangeName, onResetProgress }) {
  if (!show) return null;
  return (
    <div className="fixed inset-0 bg-black/60 flex items-center justify-center z-50 p-4">
      <div className="bg-slate-800 rounded-xl p-5 max-w-xs w-full border border-slate-700">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-bold text-white">Settings</h3>
          <button onClick={onClose} className="text-slate-400 hover:text-white">‚úï</button>
        </div>
        <div className="space-y-3">
          <button onClick={() => setSoundEnabled(!soundEnabled)} className={`w-full py-2.5 rounded-lg border text-sm ${soundEnabled ? 'bg-green-600/30 border-green-600/50 text-green-300' : 'bg-slate-700/50 border-slate-600 text-slate-400'}`}>
            {soundEnabled ? 'üîä Sound On' : 'üîá Sound Off'}
          </button>
          <button onClick={() => setVoiceEnabled(!voiceEnabled)} className={`w-full py-2.5 rounded-lg border text-sm ${voiceEnabled ? 'bg-green-600/30 border-green-600/50 text-green-300' : 'bg-slate-700/50 border-slate-600 text-slate-400'}`}>
            {voiceEnabled ? 'üéôÔ∏è Voice On' : 'üîï Voice Off'}
          </button>
          <hr className="border-slate-700" />
          <button onClick={onChangeName} className="w-full py-2.5 bg-slate-700 border border-slate-600 rounded-lg text-white text-sm hover:bg-slate-600">
            ‚úèÔ∏è Change Name
          </button>
          <button onClick={onResetProgress} className="w-full py-2.5 bg-red-600/20 border border-red-600/50 rounded-lg text-red-300 text-sm hover:bg-red-600/30">
            üóëÔ∏è Reset All Progress
          </button>
        </div>
        <button onClick={onClose} className="w-full mt-4 py-2.5 bg-slate-600 hover:bg-slate-500 rounded-lg text-white">Done</button>
      </div>
    </div>
  );
}

function MainMenu({ playerName, onPlay, onMultiplayer, onOnline, onLearn, onChangeName, soundEnabled, setSoundEnabled, voiceEnabled, setVoiceEnabled, onResetProgress }) {
  const [showSettings, setShowSettings] = useState(false);
  const [greeting] = useState(() => getRandomItem(GREETINGS));
  const [quote] = useState(() => getRandomItem(CHESS_QUOTES));
  const [tip] = useState(() => getRandomItem(PRO_TIPS));
  
  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-4 sm:p-6">
      <SettingsButton onClick={() => setShowSettings(true)} />
      <SettingsModal 
        show={showSettings} 
        onClose={() => setShowSettings(false)} 
        soundEnabled={soundEnabled} 
        setSoundEnabled={setSoundEnabled} 
        voiceEnabled={voiceEnabled} 
        setVoiceEnabled={setVoiceEnabled}
        onChangeName={() => { setShowSettings(false); onChangeName(); }}
        onResetProgress={() => { onResetProgress(); setShowSettings(false); }}
      />
      
      <div className="max-w-md mx-auto pt-4 sm:pt-8">
        <div className="text-center mb-4 sm:mb-6">
          <div className="text-4xl sm:text-5xl mb-2 sm:mb-3">‚ôüÔ∏è</div>
          <h1 className="text-2xl sm:text-3xl font-bold text-white mb-1 sm:mb-2">Chess</h1>
          <p className="text-green-400 font-medium text-sm sm:text-base">{greeting}</p>
          <p className="text-slate-500 text-xs sm:text-sm mt-1">Hey {playerName}!</p>
        </div>
        
        {/* Quote Card */}
        <div className="bg-slate-800/40 rounded-xl p-3 sm:p-4 mb-3 sm:mb-4 border border-slate-700/50">
          <p className="text-slate-300 text-xs sm:text-sm italic">"{quote.quote}"</p>
          <p className="text-slate-500 text-[10px] sm:text-xs mt-1.5 sm:mt-2">‚Äî {quote.author}</p>
        </div>
        
        {/* Pro Tip */}
        <div className="bg-blue-600/10 rounded-xl p-2.5 sm:p-3 mb-4 sm:mb-6 border border-blue-600/30">
          <p className="text-blue-300 text-xs sm:text-sm">{tip}</p>
        </div>
        
        <div className="space-y-2 sm:space-y-3">
          <button onClick={onPlay} className="w-full p-3 sm:p-4 rounded-xl text-left bg-green-600/20 hover:bg-green-600/30 active:bg-green-600/40 border border-green-600/50 transition-all">
            <div className="flex items-center gap-2.5 sm:gap-3">
              <div className="w-9 h-9 sm:w-10 sm:h-10 rounded-lg bg-green-600 flex items-center justify-center text-lg sm:text-xl">ü§ñ</div>
              <div>
                <h2 className="font-semibold text-white text-sm sm:text-base">Play vs Computer</h2>
                <p className="text-slate-400 text-xs sm:text-sm">Challenge the AI opponent</p>
              </div>
            </div>
          </button>
          <button onClick={onOnline} className="w-full p-3 sm:p-4 rounded-xl text-left bg-cyan-600/20 hover:bg-cyan-600/30 active:bg-cyan-600/40 border border-cyan-600/50 transition-all">
            <div className="flex items-center gap-2.5 sm:gap-3">
              <div className="w-9 h-9 sm:w-10 sm:h-10 rounded-lg bg-cyan-600 flex items-center justify-center text-lg sm:text-xl">üåê</div>
              <div>
                <h2 className="font-semibold text-white text-sm sm:text-base">Online Multiplayer</h2>
                <p className="text-slate-400 text-xs sm:text-sm">Play with a friend remotely</p>
              </div>
            </div>
          </button>
          <button onClick={onMultiplayer} className="w-full p-3 sm:p-4 rounded-xl text-left bg-purple-600/20 hover:bg-purple-600/30 active:bg-purple-600/40 border border-purple-600/50 transition-all">
            <div className="flex items-center gap-2.5 sm:gap-3">
              <div className="w-9 h-9 sm:w-10 sm:h-10 rounded-lg bg-purple-600 flex items-center justify-center text-lg sm:text-xl">üë•</div>
              <div>
                <h2 className="font-semibold text-white text-sm sm:text-base">Local Multiplayer</h2>
                <p className="text-slate-400 text-xs sm:text-sm">Same device, two players</p>
              </div>
            </div>
          </button>
          <button onClick={onLearn} className="w-full p-3 sm:p-4 rounded-xl text-left bg-blue-600/20 hover:bg-blue-600/30 active:bg-blue-600/40 border border-blue-600/50 transition-all">
            <div className="flex items-center gap-2.5 sm:gap-3">
              <div className="w-9 h-9 sm:w-10 sm:h-10 rounded-lg bg-blue-600 flex items-center justify-center text-lg sm:text-xl">üìö</div>
              <div>
                <h2 className="font-semibold text-white text-sm sm:text-base">Master Openings</h2>
                <p className="text-slate-400 text-xs sm:text-sm">Learn essential first moves</p>
              </div>
            </div>
          </button>
        </div>
      </div>
    </div>
  );
}

const ChessApp = function ChessApp() {
  const [screen, setScreen] = useState('name');
  const [opening, setOpening] = useState(null);
  const [soundEnabled, setSoundEnabled] = useState(true);
  const [voiceEnabled, setVoiceEnabled] = useState(true);
  const { name, saveName, clearName } = usePlayerName();
  const { progress, markCompleted, resetProgress } = useProgress();

  useEffect(() => { if (name) setScreen('menu'); }, []);

  const handleChangeName = () => { clearName(); setScreen('name'); };

  if (screen === 'name' || !name) return <NameEntry initialName={name} onSubmit={n => { saveName(n); setScreen('menu'); }} />;
  if (screen === 'menu') return <MainMenu playerName={name} onPlay={() => setScreen('play')} onMultiplayer={() => setScreen('multiplayer')} onOnline={() => setScreen('online')} onLearn={() => setScreen('openings')} onChangeName={handleChangeName} soundEnabled={soundEnabled} setSoundEnabled={setSoundEnabled} voiceEnabled={voiceEnabled} setVoiceEnabled={setVoiceEnabled} onResetProgress={resetProgress} />;
  if (screen === 'play') return <PlayMatch playerName={name} onBack={() => setScreen('menu')} soundEnabled={soundEnabled} />;
  if (screen === 'multiplayer') return <PlayMultiplayer player1Name={name} onBack={() => setScreen('menu')} soundEnabled={soundEnabled} />;
  if (screen === 'online') return <PlayOnline playerName={name} onBack={() => setScreen('menu')} soundEnabled={soundEnabled} />;
  if (screen === 'openings') return <OpeningSelect onSelect={k => { setOpening(k); setScreen('demo'); }} onBack={() => setScreen('menu')} progress={progress} onResetProgress={resetProgress} />;
  if (screen === 'demo' && opening) return <DemoMode opening={OPENINGS[opening]} onComplete={() => setScreen('practice')} onSkip={() => setScreen('practice')} soundEnabled={soundEnabled} voiceEnabled={voiceEnabled} />;
  if (screen === 'practice' && opening) return <PracticeMode opening={OPENINGS[opening]} onBack={() => setScreen('openings')} onRewatch={() => setScreen('demo')} soundEnabled={soundEnabled} onComplete={() => markCompleted(opening)} />;
  return null;
}

const { useState, useCallback, useEffect, useRef } = React;
ReactDOM.createRoot(document.getElementById('root')).render(<ChessApp />);
  </script>
</body>
</html>
